<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ÏòÅÏñ¥ ÌïôÏäµ ÏÑúÎ∞îÏù¥Î≤å Í≤åÏûÑ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #gameContainer {
            border: 3px solid #4a90e2;
            border-radius: 10px;
            position: relative;
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
        }
        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            border-radius: 7px;
            background: #1a1a2e;
        }
        #wordDisplay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            color: white;
            font-size: 32px;
            font-weight: bold;
            z-index: 15;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            letter-spacing: 3px;
        }
        .missing-letter {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
            padding: 2px 8px;
            border-radius: 5px;
            border: 2px dashed #ff4444;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-size: 14px;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
        }
        .ui-item {
            margin-bottom: 5px;
            background: rgba(0,0,0,0.7);
            padding: 3px 8px;
            border-radius: 4px;
            border-left: 2px solid #4a90e2;
            font-size: 12px;
        }
        #wordResult {
            position: fixed !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
            background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
            border: 3px solid #44ff44;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 25;
            display: none;
            box-shadow: 0 0 40px rgba(68, 255, 68, 0.6);
            max-width: 400px;
            line-height: 1.6;
        }
        .word-complete {
            font-size: 28px;
            color: #44ff44;
            margin-bottom: 15px;
        }
        .word-meaning {
            font-size: 20px;
            color: #ffffff;
            margin-bottom: 10px;
        }
        .word-pronunciation {
            font-size: 16px;
            color: #aaaaaa;
            font-style: italic;
        }
        #levelUpModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
            border: 3px solid #ffd700;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 20;
            display: none;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
        }
        .upgrade-btn {
            display: block;
            width: 320px;
            margin: 12px auto;
            padding: 12px;
            background: linear-gradient(145deg, #4a4a6a, #3a3a5a);
            border: 2px solid #666;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .upgrade-btn:hover {
            background: linear-gradient(145deg, #5a5a7a, #4a4a6a);
            border-color: #ffd700;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #3a1a1a, #2a1a1a);
            border: 3px solid #ff4444;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 20;
            display: none;
            box-shadow: 0 0 40px rgba(255, 68, 68, 0.6);
        }
        #restartBtn {
            padding: 12px 24px;
            background: linear-gradient(145deg, #ff4444, #cc3333);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            font-size: 16px;
            margin-top: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        #restartBtn:hover {
            background: linear-gradient(145deg, #ff6666, #ff4444);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
        }
        h2 {
            margin-top: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            z-index: 25;
            pointer-events: none;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        .correct {
            color: #44ff44;
            animation: correctPulse 1s ease-out;
        }
        .incorrect {
            color: #ff4444;
            animation: incorrectShake 0.5s ease-out;
        }
        @keyframes correctPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        @keyframes incorrectShake {
            0%, 100% { transform: translate(-50%, -50%); }
            25% { transform: translate(-45%, -50%); }
            75% { transform: translate(-55%, -50%); }
        }
        .correct-answer {
            color: #44ff44;
            font-size: 36px;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 2px 2px 8px #222, 0 0 16px #44ff44;
        }
        .word-meaning {
            color: #ffd700;
            font-size: 18px;
            margin-top: 6px;
            font-weight: normal;
            text-shadow: 1px 1px 4px #222;
        }
        .word-box {
            background: rgba(20, 20, 40, 0.85);
            border: 2.5px solid #ffd700;
            border-radius: 14px;
            box-shadow: 0 4px 24px 0 rgba(0,0,0,0.35);
            padding: 18px 32px 12px 32px;
            display: inline-block;
            min-width: 180px;
            text-align: center;
            margin-top: 8px;
            margin-bottom: 8px;
            position: relative;
        }
        .word-en {
            font-family: 'Fira Mono', 'Consolas', 'monospace';
            font-size: 36px;
            color: #fff;
            letter-spacing: 4px;
            text-shadow: 0 2px 8px #222, 0 0 8px #ffd70044;
            font-weight: bold;
        }
        .missing-letter {
            color: #ff4444;
            border: none;
            border-bottom: 2.5px solid #ff4444; /* Ï†êÏÑ†X, Ïã§ÏÑ† Ïñ∏ÎçîÎùºÏù∏Îßå */
            background: transparent;
            margin: 0 2px;
            font-size: 36px;
            display: inline-block;
            vertical-align: baseline;
            line-height: 1;
            padding: 0 8px 2px 8px;
            border-radius: 0;
            min-width: 24px;
        }
        .word-ko {
            color: #ffe066;
            font-size: 18px;
            font-weight: 400;
            letter-spacing: 1px;
            margin-left: 18px;
            vertical-align: middle;
            text-align: left;
            border: none;
            text-shadow: none;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="wordDisplay">
            <span id="currentWord">appl_</span>
        </div>
        
        <div id="ui">
            <div class="ui-item">‚ù§Ô∏è HP: <span id="health">100</span></div>
            <div class="ui-item">‚≠ê Lv: <span id="level">1</span></div>
            <div class="ui-item">‚ú® XP: <span id="exp">0</span>/<span id="expMax">10</span></div>
            <div class="ui-item">üíÄ Ï≤òÏπò: <span id="kills">0</span></div>
            <div class="ui-item">üìù Îã®Ïñ¥: <span id="completedWords">0</span></div>
            <div class="ui-item">‚è±Ô∏è ÏãúÍ∞Ñ: <span id="time">0</span>Ï¥à</div>
        </div>
        
        <div id="feedback"></div>
        
        <div id="wordResult">
            <div class="word-complete" id="wordCompleteText">Loading...</div>
            <div class="word-meaning" id="wordMeaningText">Loading...</div>
            <div class="word-pronunciation" id="wordPronunciationText">Loading...</div>
        </div>
        
        <div id="levelUpModal">
            <h2>üéâ Î†àÎ≤®ÏóÖ! üéâ</h2>
            <p>ÏóÖÍ∑∏Î†àÏù¥ÎìúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî:</p>
            <button class="upgrade-btn" onclick="selectUpgrade('attackSpeed')">‚ö° Í≥µÍ≤© ÏÜçÎèÑ Ï¶ùÍ∞Ä (+20%)</button>
            <button class="upgrade-btn" onclick="selectUpgrade('moveSpeed')">üèÉ Ïù¥Îèô ÏÜçÎèÑ Ï¶ùÍ∞Ä (+15%)</button>
            <button class="upgrade-btn" onclick="selectUpgrade('projectileSize')">üí• Ìà¨ÏÇ¨Ï≤¥ ÌÅ¨Í∏∞ Ï¶ùÍ∞Ä (+25%)</button>
            <button class="upgrade-btn" onclick="selectUpgrade('health')">‚ù§Ô∏è Ï≤¥Î†• ÌöåÎ≥µ (+30)</button>
        </div>
        
        <div id="gameOver">
            <h2>üíÄ Í≤åÏûÑ Ïò§Î≤Ñ! üíÄ</h2>
            <p>ÏÉùÏ°¥ ÏãúÍ∞Ñ: <span id="finalTime">0</span>Ï¥à</p>
            <p>Ï≤òÏπòÌïú Î™¨Ïä§ÌÑ∞: <span id="finalKills">0</span>ÎßàÎ¶¨</p>
            <p>ÏôÑÏÑ±Ìïú Îã®Ïñ¥: <span id="finalWords">0</span>Í∞ú</p>
            <p>Îã¨ÏÑ± Î†àÎ≤®: <span id="finalLevel">1</span></p>
            <button id="restartBtn" onclick="restartGame()">üîÑ Îã§Ïãú ÏãúÏûë</button>
        </div>
    </div>

    <script>
        // ÌÑ∞Ïπò/ÎßàÏö∞Ïä§ Ïù¥Îèô Î™©Ìëú Ï¢åÌëú Ï†ÑÏó≠ Î≥ÄÏàò ÏÑ†Ïñ∏ (Í∞ÄÏû• ÏÉÅÎã®)
        let targetX = null;
        let targetY = null;

        // ÎßàÏö∞Ïä§/ÌÑ∞Ïπò ÎàÑÎ•¥Í≥† ÏûàÎäî ÎèôÏïà Ïù¥ÎèôÌïòÎäî ÏãúÏä§ÌÖú Î≥ÄÏàò ÏÑ†Ïñ∏
        let isPointerDown = false;
        let pointerX = null, pointerY = null;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ÏòÅÏñ¥ Îã®Ïñ¥ Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§
        const wordDatabase = [
            { word: "apple", display: "appl_", missing: "e", meaning: "ÏÇ¨Í≥º", pronunciation: "/Àà√¶p.…ôl/" },
            { word: "book", display: "b_ok", missing: "o", meaning: "Ï±Ö", pronunciation: "/b äk/" },
            { word: "cat", display: "c_t", missing: "a", meaning: "Í≥†ÏñëÏù¥", pronunciation: "/k√¶t/" },
            { word: "dog", display: "_og", missing: "d", meaning: "Í∞ú", pronunciation: "/d…îÀê…°/" },
            { word: "fish", display: "fi_h", missing: "s", meaning: "Î¨ºÍ≥†Í∏∞", pronunciation: "/f…™ É/" },
            { word: "house", display: "hou_e", missing: "s", meaning: "Ïßë", pronunciation: "/ha äs/" },
            { word: "water", display: "wat_r", missing: "e", meaning: "Î¨º", pronunciation: "/Ààw…îÀê.t…ôr/" },
            { word: "tree", display: "tr_e", missing: "e", meaning: "ÎÇòÎ¨¥", pronunciation: "/triÀê/" },
            { word: "bird", display: "b_rd", missing: "i", meaning: "ÏÉà", pronunciation: "/b…úÀêrd/" },
            { word: "moon", display: "m_on", missing: "o", meaning: "Îã¨", pronunciation: "/muÀên/" },
            { word: "star", display: "st_r", missing: "a", meaning: "Î≥Ñ", pronunciation: "/st…ëÀêr/" },
            { word: "flower", display: "flow_r", missing: "e", meaning: "ÍΩÉ", pronunciation: "/Ààfla ä.…ôr/" },
            { word: "music", display: "mu_ic", missing: "s", meaning: "ÏùåÏïÖ", pronunciation: "/ÀàmjuÀê.z…™k/" },
            { word: "friend", display: "fri_nd", missing: "e", meaning: "ÏπúÍµ¨", pronunciation: "/frend/" },
            { word: "happy", display: "hap_y", missing: "p", meaning: "ÌñâÎ≥µÌïú", pronunciation: "/Ààh√¶p.i/" }
        ];

        // ÌòÑÏû¨ Îã®Ïñ¥ ÏÉÅÌÉú
        let currentWordData = wordDatabase[0];
        let completedWords = 0;

        // ÌååÌã∞ÌÅ¥ ÏãúÏä§ÌÖú
        const particles = [];
        const bloodParticles = [];

        // Î∞∞Í≤Ω Î≥ÑÎì§
        const stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                twinkle: Math.random() * Math.PI * 2,
                speed: Math.random() * 0.02 + 0.01
            });
        }

        // Í≤åÏûÑ ÏÉÅÌÉú
        let gameState = {
            running: true,
            paused: false,
            startTime: Date.now(),
            timeElapsed: 0
        };

        // ÏõîÎìú ÌÅ¨Í∏∞ Î∞è Ïπ¥Î©îÎùº Î≥ÄÏàò Ï∂îÍ∞Ä
        const worldWidth = 3000;
        const worldHeight = 3000;
        let cameraX = 0;
        let cameraY = 0;

        // ÌîåÎ†àÏù¥Ïñ¥ Í∞ùÏ≤¥Ïóê ÏõîÎìú Ï¢åÌëú Ï∂îÍ∞Ä
        const player = {
            worldX: worldWidth / 2,
            worldY: worldHeight / 2,
            width: 24,
            height: 24,
            speed: 3,
            health: 100,
            maxHealth: 100,
            level: 1,
            exp: 0,
            expToNext: 10,
            kills: 0,
            attackSpeed: 1000,
            lastAttack: 0,
            projectileSize: 6,
            angle: 0
        };

        // ÏûÖÎ†• ÏÉÅÌÉú
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        // Í≤åÏûÑ Ïò§Î∏åÏ†ùÌä∏ Î∞∞Ïó¥
        const monsters = [];
        const projectiles = [];
        const floatingLetters = []; // Îñ†Îã§ÎãàÎäî ÏïåÌååÎ≤≥Îì§

        // Î™¨Ïä§ÌÑ∞ ÌÉÄÏûÖ Îç∞Ïù¥ÌÑ∞ Íµ¨Ï°∞ (Ïô∏Ìòï, ÏÉâÏÉÅ, ÌÅ¨Í∏∞)
        const monsterTypes = [
            { name: 'basic', color: '#ff4444', speed: 1, size: 18, health: 1, shape: 'rect' }, // Í∏∞Î≥∏Ìòï: Îπ®Í∞Ñ ÏÇ¨Í∞ÅÌòï
            { name: 'fast', color: '#44ff44', speed: 1.8, size: 14, health: 0.7, shape: 'triangle' }, // Îπ†Î•∏Ìòï: Ï¥àÎ°ù ÏÇºÍ∞ÅÌòï
            { name: 'tank', color: '#4444ff', speed: 0.7, size: 26, health: 3, shape: 'circle' }, // ÌÉ±Ïª§Ìòï: ÌååÎûÄ Ïõê
            { name: 'ranged', color: '#ffaa00', speed: 1, size: 16, health: 1, shape: 'star', shootInterval: 2000 }, // ÏõêÍ±∞Î¶¨Ìòï: ÎÖ∏ÎûÄ Î≥Ñ
            { name: 'splitter', color: '#ff44aa', speed: 1, size: 18, health: 1, shape: 'rect' }, // Î∂ÑÏó¥Ìòï: Î∂ÑÌôç ÏÇ¨Í∞ÅÌòï
            { name: 'exploder', color: '#ff8800', speed: 1.2, size: 16, health: 1, shape: 'circle' }, // Ìè≠Î∞úÌòï: Ï£ºÌô© Ïõê
            { name: 'dodger', color: '#00ffff', speed: 1.1, size: 16, health: 1, shape: 'triangle' }, // ÌöåÌîºÌòï: ÌïòÎäò ÏÇºÍ∞ÅÌòï
        ];

        // ÏãúÍ∞Ñ Í≤ΩÍ≥ºÏóê Îî∞Îùº Îì±Ïû•ÌïòÎäî Î™¨Ïä§ÌÑ∞ ÌÉÄÏûÖ Í≤∞Ï†ï Ìï®Ïàò
        function getAvailableMonsterTypes(timeElapsed) {
            if (timeElapsed < 30) return ['basic', 'fast'];
            if (timeElapsed < 60) return ['basic', 'fast', 'tank', 'splitter'];
            if (timeElapsed < 90) return ['basic', 'fast', 'tank', 'splitter', 'ranged', 'exploder'];
            return ['basic', 'fast', 'tank', 'splitter', 'ranged', 'exploder', 'dodger'];
        }

        // Î™¨Ïä§ÌÑ∞ Ïä§Ìè∞ Í¥ÄÎ†®
        let lastMonsterSpawn = 0;
        let monsterSpawnRate = 500; // 0.5Ï¥àÎßàÎã§ Î™¨Ïä§ÌÑ∞ Ïä§Ìè∞ (2Î∞∞ Îπ†Î•¥Í≤å)

        // ÏïåÌååÎ≤≥ Ïä§Ìè∞ Í¥ÄÎ†®
        let lastLetterSpawn = 0;
        let letterSpawnRate = 62; // 0.062Ï¥àÎßàÎã§ ÏïåÌååÎ≤≥ Ïä§Ìè∞ (2Î∞∞ Îçî Îπ†Î•¥Í≤å)

        // ÏõîÎìú ÌñâÏÑ±(Î≥Ñ) Î∞∞Ïó¥ Ï∂îÍ∞Ä
        const planets = [];
        // Í≤åÏûÑ ÏãúÏûë Ïãú ÌñâÏÑ± Ïó¨Îü¨ Í∞ú ÏÉùÏÑ±
        function spawnPlanets() {
            const planetCount = 5 + Math.floor(Math.random() * 4); // 5~8Í∞ú
            for (let i = 0; i < planetCount; i++) {
                const radius = 40 + Math.random() * 60; // ÌÅ¨Í∏∞ Îã§Ïñë(40~100)
                const worldX = 200 + Math.random() * (worldWidth - 400);
                const worldY = 200 + Math.random() * (worldHeight - 400);
                const color = {r: 120 + Math.random()*80, g: 120 + Math.random()*80, b: 200, a: 1};
                planets.push({
                    worldX, worldY, radius, color, timer: 0, exploded: false
                });
            }
        }

        // ÏïåÌååÎ≤≥ Î∞∞Ïó¥
        const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');

        // ÌÇ§Î≥¥Îìú Ïù¥Î≤§Ìä∏
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        });

        // ÏÉàÎ°úÏö¥ Îã®Ïñ¥ ÏÑ†ÌÉù Ìï®Ïàò
        function selectNewWord() {
            currentWordData = wordDatabase[Math.floor(Math.random() * wordDatabase.length)];
            // '_' Î¨∏Ïûê ÏóÜÏù¥, missing-letterÎßå ÎÇ®Í∏∞Í∏∞
            const display = currentWordData.display.replace('_', '<span class="missing-letter">&nbsp;</span>');
            document.getElementById('wordDisplay').innerHTML = `
                <span class="word-en">${display}</span><span class="word-ko">${currentWordData.meaning}</span>
            `;
        }

        // Îã®Ïñ¥ ÏôÑÏÑ± Í≤∞Í≥º ÌëúÏãú Ìï®Ïàò
        function showWordResult(wordData) {
            console.log('showWordResult called with:', wordData);
            
            const wordCompleteElement = document.getElementById('wordCompleteText');
            const wordMeaningElement = document.getElementById('wordMeaningText');
            const wordPronunciationElement = document.getElementById('wordPronunciationText');
            const wordResultElement = document.getElementById('wordResult');
            
            console.log('Found elements:', {
                wordComplete: wordCompleteElement,
                wordMeaning: wordMeaningElement,
                wordPronunciation: wordPronunciationElement,
                wordResult: wordResultElement
            });
            
            if (wordCompleteElement && wordMeaningElement && wordPronunciationElement && wordResultElement) {
                console.log('All elements found, showing result');
                
                wordCompleteElement.textContent = `‚ú® ${wordData.word.toUpperCase()} ‚ú®`;
                wordMeaningElement.textContent = `Îúª: ${wordData.meaning}`;
                wordPronunciationElement.textContent = `Î∞úÏùå: ${wordData.pronunciation}`;
                
                wordResultElement.style.display = 'block';
                
                // Îã®Ïñ¥ ÏùåÏÑ± ÏùΩÍ∏∞
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel();
                    
                    setTimeout(() => {
                        const utterance = new SpeechSynthesisUtterance(wordData.word);
                        utterance.lang = 'en-US';
                        utterance.rate = 0.8;
                        utterance.volume = 1.0;
                        
                        utterance.onstart = () => console.log('ÏùåÏÑ± ÏãúÏûë:', wordData.word);
                        utterance.onend = () => console.log('ÏùåÏÑ± Ï¢ÖÎ£å');
                        utterance.onerror = (event) => console.log('ÏùåÏÑ± Ïò§Î•ò:', event.error);
                        
                        speechSynthesis.speak(utterance);
                    }, 200);
                }
                
                setTimeout(() => {
                    wordResultElement.style.display = 'none';
                }, 3000);
            } else {
                console.log('Elements not found, using fallback');
                showFeedback(`${wordData.word} (${wordData.meaning})`, true);
            }
        }

        // ÌîºÎìúÎ∞± ÌëúÏãú Ìï®Ïàò
        function showFeedback(text, isCorrect) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = text;
            feedback.className = isCorrect ? 'correct' : 'incorrect';
            feedback.style.display = 'block';
            
            setTimeout(() => {
                feedback.style.display = 'none';
            }, 1000);
        }

        // ÌååÌã∞ÌÅ¥ ÏÉùÏÑ± Ìï®Ïàò
        function createParticle(x, y, type = 'normal') {
            const particle = {
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 1,
                decay: Math.random() * 0.02 + 0.01,
                size: Math.random() * 3 + 1,
                type: type
            };

            if (type === 'blood') {
                particle.color = `hsl(${Math.random() * 30}, 100%, ${Math.random() * 30 + 40}%)`;
                bloodParticles.push(particle);
            } else if (type === 'correct') {
                particle.color = `hsl(120, 100%, ${Math.random() * 30 + 50}%)`;
                particles.push(particle);
            } else {
                particle.color = `hsl(${Math.random() * 60 + 180}, 100%, 70%)`;
                particles.push(particle);
            }
        }

        // Î™¨Ïä§ÌÑ∞ ÏÉùÏÑ± Ìï®Ïàò (ÌÉÄÏûÖÎ≥ÑÎ°ú ÏÉùÏÑ±)
        function createMonster() {
            const availableTypes = getAvailableMonsterTypes(gameState.timeElapsed);
            const typeName = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            const type = monsterTypes.find(t => t.name === typeName);

            // Î™¨Ïä§ÌÑ∞ ÏúÑÏπò ÎûúÎç§ ÏÉùÏÑ± (Í∏∞Ï°¥ ÏΩîÎìú Ïú†ÏßÄ)
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -30; break;
                case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
                case 3: x = -30; y = Math.random() * canvas.height; break;
            }

            // Î™¨Ïä§ÌÑ∞, ÏïåÌååÎ≤≥ Îì± Ïò§Î∏åÏ†ùÌä∏ ÏÉùÏÑ± Ïãú worldX, worldY ÏÇ¨Ïö©
            monsters.push({
                worldX: x, // Í∏∞Ï°¥ x ‚Üí worldX
                worldY: y, // Í∏∞Ï°¥ y ‚Üí worldY
                width: type.size,
                height: type.size,
                speed: type.speed + Math.random() * 0.3,
                health: type.health,
                color: type.color,
                angle: 0,
                pulse: Math.random() * Math.PI * 2,
                name: type.name,
                shape: type.shape,
                shootInterval: type.shootInterval || null,
                lastShot: 0,
                // ÌäπÏàò Î™¨Ïä§ÌÑ∞Ïö© ÏÜçÏÑ±
                splitChild: false, // Î∂ÑÏó¥Ìòï ÏûêÏãù Ïó¨Î∂Ä
                exploded: false,   // Ìè≠Î∞úÌòï ÏûêÌè≠ Ïó¨Î∂Ä
                dodgeCooldown: 0   // ÌöåÌîºÌòï Ïø®ÌÉÄÏûÑ
            });
        }

        // Îñ†Îã§ÎãàÎäî ÏïåÌååÎ≤≥ ÏÉùÏÑ± Ìï®Ïàò
        function createFloatingLetter() {
            // ÎûúÎç§ ÏïåÌååÎ≤≥ ÏÑ†ÌÉù (Ï†ïÎãµ ÏïåÌååÎ≤≥Ïù¥ Îçî ÏûêÏ£º ÎÇòÏò§ÎèÑÎ°ù ‚Üí Ïò§Îãµ ÌôïÎ•† ÎÜíÏûÑ)
            let letter;
            if (Math.random() < 0.3) { // 30% ÌôïÎ•†Î°ú Ï†ïÎãµ
                letter = currentWordData.missing;
            } else { // 70% ÌôïÎ•†Î°ú ÎûúÎç§ Ïò§Îãµ ÏïåÌååÎ≤≥
                // Ï†ïÎãµÏù¥ ÏïÑÎãå ÏïåÌååÎ≤≥Îßå ÎΩëÍ∏∞
                let wrongs = alphabet.filter(a => a !== currentWordData.missing);
                letter = wrongs[Math.floor(Math.random() * wrongs.length)];
            }

            const isCorrect = letter === currentWordData.missing;

            // ÌôîÎ©¥ ÏúÑÏ™ΩÏóêÏÑú ÏãúÏûëÌï¥ÏÑú ÏïÑÎûòÎ°ú Ïù¥Îèô - Î™®Îì† ÏïåÌååÎ≤≥ ÎèôÏùºÌïú ÏÉâÏÉÅ
            floatingLetters.push({
                worldX: Math.random() * (canvas.width - 40) + 20, // ÌôîÎ©¥ Ï¢åÌëú ‚Üí ÏõîÎìú Ï¢åÌëú
                worldY: -30, // ÌôîÎ©¥ Ï¢åÌëú ‚Üí ÏõîÎìú Ï¢åÌëú
                width: 30,
                height: 30,
                vx: (Math.random() - 0.5) * 2, // Ï¢åÏö∞Î°ú ÏïΩÍ∞Ñ ÌùîÎì§Î¶º
                vy: 1.5 + Math.random() * 1, // ÏïÑÎûòÎ°ú Ïù¥Îèô ÏÜçÎèÑ
                letter: letter,
                isCorrect: isCorrect,
                color: '#66aaff', // Î™®Îì† ÏïåÌååÎ≤≥ ÎèôÏùºÌïú ÌååÎûÄÏÉâ
                pulse: Math.random() * Math.PI * 2,
                collected: false
            });
        }

        // Ìà¨ÏÇ¨Ï≤¥ ÏÉùÏÑ± Ìï®Ïàò
        function createProjectile() {
            if (monsters.length === 0) return;

            // Í∞ÄÏû• Í∞ÄÍπåÏö¥ Î™¨Ïä§ÌÑ∞ Ï∞æÍ∏∞
            let nearestMonster = monsters[0];
            let minDistance = Infinity;

            monsters.forEach(monster => {
                const dx = monster.worldX - player.worldX; // worldX Í∏∞Ï§Ä
                const dy = monster.worldY - player.worldY; // worldY Í∏∞Ï§Ä
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestMonster = monster;
                }
            });

            // Ìà¨ÏÇ¨Ï≤¥ ÏÉùÏÑ±
            const dx = nearestMonster.worldX - player.worldX; // worldX Í∏∞Ï§Ä
            const dy = nearestMonster.worldY - player.worldY; // worldY Í∏∞Ï§Ä
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            projectiles.push({
                worldX: player.worldX + player.width / 2, // worldX Í∏∞Ï§Ä
                worldY: player.worldY + player.height / 2, // worldY Í∏∞Ï§Ä
                vx: (dx / distance) * 6,
                vy: (dy / distance) * 6,
                size: player.projectileSize,
                color: '#00ff88',
                trail: [],
                life: 1
            });
        }

        // Ï∂©Îèå Í∞êÏßÄ Ìï®Ïàò
        function checkCollision(rect1, rect2) {
            return rect1.worldX < rect2.worldX + rect2.width &&
                   rect1.worldX + rect1.width > rect2.worldX &&
                   rect1.worldY < rect2.worldY + rect2.height &&
                   rect1.worldY + rect1.height > rect2.worldY;
        }

        // ÏõêÍ≥º ÏÇ¨Í∞ÅÌòï Ï∂©Îèå Í∞êÏßÄ
        function checkCircleRectCollision(circle, rect) {
            const dx = circle.worldX - Math.max(rect.worldX, Math.min(circle.worldX, rect.worldX + rect.width)); // worldX Í∏∞Ï§Ä
            const dy = circle.worldY - Math.max(rect.worldY, Math.min(circle.worldY, rect.worldY + rect.height)); // worldY Í∏∞Ï§Ä
            return (dx * dx + dy * dy) < (circle.size * circle.size);
        }

        // Í≤åÏûÑ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function update() {
            if (!gameState.running || gameState.paused) return;

            const currentTime = Date.now();
            gameState.timeElapsed = Math.floor((currentTime - gameState.startTime) / 1000);

            // ÌîåÎ†àÏù¥Ïñ¥ Ïù¥Îèô Î∞è Í∞ÅÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
            let moving = false;
            if (keys.w && player.worldY > 0) {
                player.worldY -= player.speed;
                moving = true;
            }
            if (keys.s && player.worldY < worldHeight - player.height) {
                player.worldY += player.speed;
                moving = true;
            }
            if (keys.a && player.worldX > 0) {
                player.worldX -= player.speed;
                moving = true;
            }
            if (keys.d && player.worldX < worldWidth - player.width) {
                player.worldX += player.speed;
                moving = true;
            }

            // ÌÑ∞Ïπò/ÎßàÏö∞Ïä§ ÎàÑÎ•¥Í≥† ÏûàÎäî ÎèôÏïà Ïù¥ÎèôÌïòÎäî ÏãúÏä§ÌÖú Î°úÏßÅ ÏàòÏ†ï
            if (isPointerDown && pointerX !== null && pointerY !== null) {
                const dx = pointerX - (player.worldX + player.width/2);
                const dy = pointerY - (player.worldY + player.height/2);
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 4) {
                    player.worldX += (dx / dist) * player.speed;
                    player.worldY += (dy / dist) * player.speed;
                    moving = true;
                }
            }

            if (moving) {
                player.angle += 0.2;
                if (Math.random() < 0.3) {
                    createParticle(player.worldX + player.width/2, player.worldY + player.height, 'normal');
                }
            }

            // Î≥Ñ ÍπúÎπ°ÏûÑ ÏóÖÎç∞Ïù¥Ìä∏
            stars.forEach(star => {
                star.twinkle += star.speed;
            });

            // Î™¨Ïä§ÌÑ∞ Ïä§Ìè∞
            if (currentTime - lastMonsterSpawn > monsterSpawnRate) {
                createMonster();
                lastMonsterSpawn = currentTime;
                // 30Ï¥àÎßàÎã§ Ïä§Ìè∞ ÏÜçÎèÑ Ï¶ùÍ∞Ä, ÏµúÏÜå 200ms
                monsterSpawnRate = Math.max(200, 500 - Math.floor(gameState.timeElapsed / 30) * 75);
            }

            // ÏïåÌååÎ≤≥ Ïä§Ìè∞
            if (currentTime - lastLetterSpawn > letterSpawnRate) {
                createFloatingLetter();
                lastLetterSpawn = currentTime;
                // 30Ï¥àÎßàÎã§ Ïä§Ìè∞ ÏÜçÎèÑ Ï¶ùÍ∞Ä, ÏµúÏÜå 30ms
                letterSpawnRate = Math.max(30, 62 - Math.floor(gameState.timeElapsed / 30) * 12);
            }

            // Ìà¨ÏÇ¨Ï≤¥ Î∞úÏÇ¨
            if (currentTime - player.lastAttack > player.attackSpeed) {
                createProjectile();
                player.lastAttack = currentTime;
            }

            // Î™¨Ïä§ÌÑ∞ ÏóÖÎç∞Ïù¥Ìä∏ (Í∏∞Ï°¥Í≥º ÎèôÏùº)
            for (let i = monsters.length - 1; i >= 0; i--) {
                const monster = monsters[i];
                const dx = player.worldX - monster.worldX; // worldX Í∏∞Ï§Ä
                const dy = player.worldY - monster.worldY; // worldY Í∏∞Ï§Ä
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Ìè≠Î∞úÌòï: ÌîåÎ†àÏù¥Ïñ¥ Í∑ºÏ≤òÏóêÏÑú ÏûêÌè≠
                if (monster.name === 'exploder' && !monster.exploded && distance < 40) {
                    // ÏûêÌè≠ ÌååÌã∞ÌÅ¥ Ìö®Í≥º
                    for (let j = 0; j < 18; j++) {
                        createParticle(monster.worldX + monster.width/2, monster.worldY + monster.height/2, 'blood');
                    }
                    // ÌîåÎ†àÏù¥Ïñ¥ Îç∞ÎØ∏ÏßÄ
                    player.health -= 20;
                    monster.exploded = true;
                    monsters.splice(i, 1);
                    if (player.health <= 0) gameOver();
                    continue;
                }

                // ÌöåÌîºÌòï: Ìà¨ÏÇ¨Ï≤¥ Ï†ëÍ∑º Ïãú ÏàúÍ∞Ñ Ïù¥Îèô(Ïø®ÌÉÄÏûÑ 2Ï¥à)
                if (monster.name === 'dodger') {
                    if (monster.dodgeCooldown > 0) monster.dodgeCooldown--;
                    for (const proj of projectiles) {
                        const pdx = proj.worldX - (monster.worldX + monster.width/2); // worldX Í∏∞Ï§Ä
                        const pdy = proj.worldY - (monster.worldY + monster.height/2); // worldY Í∏∞Ï§Ä
                        const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                        if (pdist < 60 && monster.dodgeCooldown === 0) {
                            // ÏàúÍ∞Ñ Ïù¥Îèô(Îßµ ÎÇ¥ ÎûúÎç§ ÏúÑÏπò)
                            monster.worldX = Math.random() * (worldWidth - monster.width); // worldX Í∏∞Ï§Ä
                            monster.worldY = Math.random() * (worldHeight - monster.height); // worldY Í∏∞Ï§Ä
                            monster.dodgeCooldown = 120; // 2Ï¥à(60fps Í∏∞Ï§Ä)
                            break;
                        }
                    }
                }

                // Í∏∞Ï°¥ Ïù¥Îèô/Ï∂©Îèå ÏΩîÎìú
                monster.worldX += (dx / distance) * monster.speed; // worldX Í∏∞Ï§Ä
                monster.worldY += (dy / distance) * monster.speed; // worldY Í∏∞Ï§Ä
                monster.angle += 0.1;
                monster.pulse += 0.15;

                // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ Î™¨Ïä§ÌÑ∞ Ï∂©Îèå
                if (checkCollision(player, monster)) {
                    player.health -= 10;
                    // ÌòàÌùî ÌååÌã∞ÌÅ¥ ÏÉùÏÑ±
                    for (let j = 0; j < 8; j++) {
                        createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'blood');
                    }
                    monsters.splice(i, 1);
                    
                    if (player.health <= 0) {
                        gameOver();
                    }
                }

                // Î∂ÑÏó¥Ìòï: Ï£ΩÏùÑ Îïå ÏûëÏùÄ Î™¨Ïä§ÌÑ∞ Ïó¨Îü¨ ÎßàÎ¶¨ ÏÉùÏÑ±
                if (monster.name === 'splitter' && monster.health <= 0 && !monster.splitChild) {
                    for (let k = 0; k < 2 + Math.floor(Math.random() * 2); k++) {
                        monsters.push({
                            worldX: monster.worldX + Math.random() * 20 - 10, // worldX Í∏∞Ï§Ä
                            worldY: monster.worldY + Math.random() * 20 - 10, // worldY Í∏∞Ï§Ä
                            width: 12,
                            height: 12,
                            speed: 1.5,
                            health: 0.5,
                            color: '#ff99ee',
                            angle: 0,
                            pulse: Math.random() * Math.PI * 2,
                            name: 'basic',
                            shape: 'rect',
                            splitChild: true,
                            exploded: false,
                            dodgeCooldown: 0
                        });
                    }
                    monsters.splice(i, 1);
                    continue;
                }

                // Î™¨Ïä§ÌÑ∞ ÏÇ¨Îßù Ï≤òÎ¶¨ Î∂ÄÎ∂ÑÏóêÏÑú ÌååÌã∞ÌÅ¥ Ìö®Í≥ºÎ•º Î™®Îì† ÌÉÄÏûÖÏóê Í≥µÌÜµ Ï†ÅÏö©
                if (monster.health <= 0) {
                    // ÌååÌã∞ÌÅ¥ Ìö®Í≥º (Î™®Îì† Î™¨Ïä§ÌÑ∞ Í≥µÌÜµ)
                    for (let i = 0; i < 12; i++) {
                        createParticle(monster.worldX + monster.width/2, monster.worldY + monster.height/2, 'blood');
                    }
                    monsters.splice(i, 1);
                    // Î™¨Ïä§ÌÑ∞ Ï≤òÏπò Ïãú Í≤ΩÌóòÏπò 1Î°ú Í∞êÏÜå
                    player.kills++;
                    player.exp += 1;
                    if (player.exp >= player.expToNext) levelUp();
                }
            }

            // Îñ†Îã§ÎãàÎäî ÏïåÌååÎ≤≥ ÏóÖÎç∞Ïù¥Ìä∏
            floatingLetters.forEach(letter => {
                if (!letter.collected) {
                    letter.worldX += letter.vx; // worldX Í∏∞Ï§Ä
                    letter.worldY += letter.vy; // worldY Í∏∞Ï§Ä
                    letter.pulse += 0.1;

                    // ÌîåÎ†àÏù¥Ïñ¥ÏôÄ ÏïåÌååÎ≤≥ Ï∂©Îèå
                    if (checkCollision(player, letter)) {
                        letter.collected = true;
                        
                        // Ï†ïÎãµ ÎßûÏ∂ú Îïå Î¨∏Ï†ú ÏòÅÏó≠Ïóê Ï†ïÎãµ ÌîºÎìúÎ∞± ÌëúÏãú, ÏùºÏ†ï ÏãúÍ∞Ñ ÌõÑ Îã§Ïùå Î¨∏Ï†úÎ°ú Ï†ÑÌôò
                        if (letter.isCorrect) {
                            completedWords++;
                            showFeedback(`Ï†ïÎãµ!`, true);
                            // ÌôîÎ©¥ ÏÉÅÎã® Î¨∏Ï†ú ÏòÅÏó≠Ïóê Ï†ïÎãµ ÌëúÏãú
                            const wordDisplay = document.getElementById('wordDisplay');
                            wordDisplay.innerHTML = `<span class='correct-answer'>Ï†ïÎãµ! ${currentWordData.word.toUpperCase()}</span>`;
                            // Ï†ïÎãµ Îã®Ïñ¥ ÏùåÏÑ± Ï∂úÎ†•
                            if ('speechSynthesis' in window) {
                                speechSynthesis.cancel();
                                setTimeout(() => {
                                    const utterance = new SpeechSynthesisUtterance(currentWordData.word);
                                    utterance.lang = 'en-US';
                                    utterance.rate = 0.8;
                                    utterance.volume = 1.0;
                                    speechSynthesis.speak(utterance);
                                }, 200);
                            }
                            // ÏÑ±Í≥µ ÌååÌã∞ÌÅ¥
                            for (let i = 0; i < 15; i++) {
                                createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'correct');
                            }
                            // Í≤ΩÌóòÏπò Î≥¥ÏÉÅ (Î†àÎ≤® √ó 10)
                            player.exp += player.level * 10;
                            if (player.exp >= player.expToNext) levelUp();
                            // Î™®Îì† ÏïåÌååÎ≤≥ Ìè≠Î∞ú (Îç∞ÎØ∏ÏßÄ ÏóÜÏù¥ ÌååÌã∞ÌÅ¥Îßå)
                            floatingLetters.forEach(fl => {
                                for (let j = 0; j < 10; j++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const dist = 10 + Math.random() * 20;
                                    createParticle(
                                        fl.worldX + fl.width/2 + Math.cos(angle) * dist,
                                        fl.worldY + fl.height/2 + Math.sin(angle) * dist,
                                        'blood'
                                    );
                                }
                                fl.collected = true;
                            });
                            // 2Ï¥à ÌõÑ Îã§Ïùå Î¨∏Ï†úÎ°ú Ï†ÑÌôò
                            setTimeout(() => {
                                selectNewWord();
                            }, 2000);
                            return;
                        } else {
                            // ÌãÄÎ¶∞ ÏïåÌååÎ≤≥
                            player.health -= 15;
                            showFeedback(`ÌãÄÎ†∏ÏäµÎãàÎã§! ${letter.letter}`, false);
                            
                            // Îç∞ÎØ∏ÏßÄ ÌååÌã∞ÌÅ¥
                            for (let i = 0; i < 8; i++) {
                                createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'blood');
                            }
                            
                            if (player.health <= 0) {
                                gameOver();
                            }
                        }
                    }

                    // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞Ñ ÏïåÌååÎ≤≥ Ï†úÍ±∞
                    if (letter.worldY > worldHeight + 50) { // worldY Í∏∞Ï§Ä
                        letter.collected = true;
                    }
                }
            });

            // ÏàòÏßëÎêú ÏïåÌååÎ≤≥ Ï†úÍ±∞
            floatingLetters.splice(0, floatingLetters.length, ...floatingLetters.filter(letter => !letter.collected));

            // Ìà¨ÏÇ¨Ï≤¥ ÏóÖÎç∞Ïù¥Ìä∏
            projectiles.forEach(projectile => {
                // Ìä∏Î†àÏùº Ï∂îÍ∞Ä
                projectile.trail.push({x: projectile.worldX, y: projectile.worldY}); // worldX, worldY Í∏∞Ï§Ä
                if (projectile.trail.length > 8) {
                    projectile.trail.shift();
                }

                projectile.worldX += projectile.vx; // worldX Í∏∞Ï§Ä
                projectile.worldY += projectile.vy; // worldY Í∏∞Ï§Ä
                projectile.life -= 0.01;

                // Ìà¨ÏÇ¨Ï≤¥ÏôÄ Î™¨Ïä§ÌÑ∞ Ï∂©Îèå
                monsters.forEach(monster => {
                    if (checkCircleRectCollision(projectile, monster)) {
                        // Î™¨Ïä§ÌÑ∞ Ï≤òÏπò ÌååÌã∞ÌÅ¥
                        for (let i = 0; i < 12; i++) {
                            createParticle(monster.worldX + monster.width/2, monster.worldY + monster.height/2, 'blood');
                        }
                        
                        monster.health -= 1; // Î™¨Ïä§ÌÑ∞ Ï≤òÏπò Ïãú health Í∞êÏÜå
                        if (monster.health <= 0) {
                            player.kills++;
                            player.exp += 1;
                            if (player.exp >= player.expToNext) levelUp();
                        }
                        projectiles.splice(projectiles.indexOf(projectile), 1);
                    }
                });

                // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÍ±∞ÎÇò ÏàòÎ™ÖÏù¥ Îã§Ìïú Ìà¨ÏÇ¨Ï≤¥ Ï†úÍ±∞
                if (projectile.worldX < -50 || projectile.worldX > worldWidth + 50 || 
                    projectile.worldY < -50 || projectile.worldY > worldHeight + 50 || 
                    projectile.life <= 0) {
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
            });

            // ÌååÌã∞ÌÅ¥ ÏóÖÎç∞Ïù¥Ìä∏
            particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                particle.life -= particle.decay;
            });
            
            bloodParticles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.vy += 0.1;
                particle.life -= particle.decay;
            });

            // Ï£ΩÏùÄ ÌååÌã∞ÌÅ¥ Ï†úÍ±∞
            particles.splice(0, particles.length, ...particles.filter(p => p.life > 0));
            bloodParticles.splice(0, bloodParticles.length, ...bloodParticles.filter(p => p.life > 0));

            // ÌñâÏÑ± ÌÉÄÏù¥Î®∏, ÏÉâÏÉÅ Î≥ÄÌôî, Ìè≠Î∞ú Ï≤òÎ¶¨
            planets.forEach(planet => {
                if (planet.exploded) return;
                planet.timer += 1; // ÌîÑÎ†àÏûÑ Îã®ÏúÑ(60ÌîÑÎ†àÏûÑ=1Ï¥à)
                // 20Ï¥à(1200ÌîÑÎ†àÏûÑ)ÍπåÏßÄ Ï†êÏ†ê Î∂âÏñ¥Ïßê
                const t = Math.min(planet.timer / 1200, 1);
                planet.color.r = 120 + t * 120; // r: 120~240
                planet.color.g = 120 * (1-t) + 30 * t; // g: 120~30
                planet.color.b = 200 * (1-t) + 30 * t; // b: 200~30
                // Ìè≠Î∞ú
                if (planet.timer >= 1200) {
                    planet.exploded = true;
                    // Ìè≠Î∞ú ÌååÌã∞ÌÅ¥ Ìö®Í≥º
                    for (let i = 0; i < 40; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = planet.radius + Math.random() * 40;
                        createParticle(
                            planet.worldX + Math.cos(angle) * dist,
                            planet.worldY + Math.sin(angle) * dist,
                            'blood'
                        );
                    }
                    // Ìè≠Î∞ú Î∞òÍ≤Ω ÎÇ¥ ÌîåÎ†àÏù¥Ïñ¥/Î™¨Ïä§ÌÑ∞ ÎåÄÎØ∏ÏßÄ
                    const explosionRadius = planet.radius + 120;
                    // ÌîåÎ†àÏù¥Ïñ¥
                    const pdx = player.worldX + player.width/2 - planet.worldX;
                    const pdy = player.worldY + player.height/2 - planet.worldY;
                    if (Math.sqrt(pdx*pdx + pdy*pdy) < explosionRadius) {
                        player.health -= 40;
                        if (player.health <= 0) gameOver();
                    }
                    // Î™¨Ïä§ÌÑ∞
                    for (let i = monsters.length - 1; i >= 0; i--) {
                        const m = monsters[i];
                        const mdx = m.worldX + m.width/2 - planet.worldX;
                        const mdy = m.worldY + m.height/2 - planet.worldY;
                        if (Math.sqrt(mdx*mdx + mdy*mdy) < explosionRadius) {
                            monsters.splice(i, 1);
                        }
                    }
                }
            });

            // Ïπ¥Î©îÎùº Î™©Ìëú ÏúÑÏπò Í≥ÑÏÇ∞
            const targetCameraX = player.worldX - canvas.width / 2;
            const targetCameraY = player.worldY - canvas.height / 2;
            // lerp(Î≥¥Í∞Ñ)ÏúºÎ°ú Î∂ÄÎìúÎüΩÍ≤å Ïù¥Îèô
            cameraX += (targetCameraX - cameraX) * 0.1;
            cameraY += (targetCameraY - cameraY) * 0.1;
            // Îßµ Í≤ΩÍ≥ÑÏóêÏÑú Ïπ¥Î©îÎùºÍ∞Ä Î≤óÏñ¥ÎÇòÏßÄ ÏïäÎèÑÎ°ù Î≥¥Ï†ï
            cameraX = Math.max(0, Math.min(cameraX, worldWidth - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, worldHeight - canvas.height));

            updateUI();
        }

        // Î†åÎçîÎßÅ Ìï®Ïàò
        function render() {
            // Î∞∞Í≤Ω Í∑∏ÎùºÎîîÏñ∏Ìä∏
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f1419');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Î≥Ñ Í∑∏Î¶¨Í∏∞
            stars.forEach(star => {
                const alpha = (Math.sin(star.twinkle) + 1) / 2;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // ÌòàÌùî ÌååÌã∞ÌÅ¥ Í∑∏Î¶¨Í∏∞
            bloodParticles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x - cameraX, particle.y - cameraY, particle.size, 0, Math.PI * 2); // Ïπ¥Î©îÎùº Ïò§ÌîÑÏÖã Ï†ÅÏö©
                ctx.fill();
                ctx.restore();
            });

            // ÌîåÎ†àÏù¥Ïñ¥ Í∑∏Î¶¨Í∏∞ (Î∞úÍ¥ë Ìö®Í≥º)
            ctx.save();
            ctx.shadowColor = '#4499ff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#4499ff';
            ctx.translate(player.worldX - cameraX, player.worldY - cameraY); // worldX, worldY Í∏∞Ï§Ä
            ctx.rotate(player.angle);
            ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
            ctx.restore();

            // ÌîåÎ†àÏù¥Ïñ¥ Ï§ëÏã¨Ï†ê
            ctx.fillStyle = '#88ccff';
            ctx.beginPath();
            ctx.arc(player.worldX - cameraX, player.worldY - cameraY, 3, 0, Math.PI * 2); // worldX, worldY Í∏∞Ï§Ä
            ctx.fill();

            // Î™¨Ïä§ÌÑ∞ Í∑∏Î¶¨Í∏∞ (ÌÉÄÏûÖÎ≥Ñ Ïô∏Ìòï)
            monsters.forEach(monster => {
                const pulse = Math.sin(monster.pulse) * 0.2 + 1;
                ctx.save();
                ctx.shadowColor = monster.color;
                ctx.shadowBlur = 10;
                ctx.fillStyle = monster.color;
                ctx.translate(monster.worldX - cameraX, monster.worldY - cameraY); // worldX, worldY Í∏∞Ï§Ä
                ctx.rotate(monster.angle);
                ctx.scale(pulse, pulse);
                // ÌÉÄÏûÖÎ≥ÑÎ°ú ÎèÑÌòï Îã§Î•¥Í≤å Í∑∏Î¶¨Í∏∞
                if (monster.shape === 'rect') {
                    // ÏÇ¨Í∞ÅÌòï
                    ctx.fillRect(-monster.width/2, -monster.height/2, monster.width, monster.height);
                } else if (monster.shape === 'circle') {
                    // Ïõê
                    ctx.beginPath();
                    ctx.arc(0, 0, monster.width/2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (monster.shape === 'triangle') {
                    // ÏÇºÍ∞ÅÌòï
                    ctx.beginPath();
                    ctx.moveTo(0, -monster.width/2);
                    ctx.lineTo(-monster.width/2, monster.width/2);
                    ctx.lineTo(monster.width/2, monster.width/2);
                    ctx.closePath();
                    ctx.fill();
                } else if (monster.shape === 'star') {
                    // Î≥Ñ
                    drawStar(ctx, 0, 0, monster.width/2, monster.width/4, 5);
                }
                ctx.restore();
            });

            // Îñ†Îã§ÎãàÎäî ÏïåÌååÎ≤≥ Í∑∏Î¶¨Í∏∞
            floatingLetters.forEach(letter => {
                if (!letter.collected) {
                    const pulse = Math.sin(letter.pulse) * 0.2 + 1;
                    
                    // ÏïåÌååÎ≤≥ Î∞∞Í≤Ω (ÏõêÌòï)
                    ctx.save();
                    ctx.shadowColor = letter.color;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = letter.color;
                    ctx.beginPath();
                    ctx.arc(letter.worldX - cameraX, letter.worldY - cameraY, (letter.width/2) * pulse, 0, Math.PI * 2); // worldX, worldY Í∏∞Ï§Ä
                    ctx.fill();
                    ctx.restore();

                    // ÏïåÌååÎ≤≥ ÌÖçÏä§Ìä∏
                    ctx.save();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(letter.letter.toUpperCase(), letter.worldX - cameraX, letter.worldY - cameraY); // worldX, worldY Í∏∞Ï§Ä
                    ctx.fillText(letter.letter.toUpperCase(), letter.worldX - cameraX, letter.worldY - cameraY); // worldX, worldY Í∏∞Ï§Ä
                    ctx.restore();
                }
            });

            // Ìà¨ÏÇ¨Ï≤¥ Ìä∏Î†àÏùº Î∞è Ìà¨ÏÇ¨Ï≤¥ Í∑∏Î¶¨Í∏∞
            projectiles.forEach(projectile => {
                // Ìä∏Î†àÏùº Í∑∏Î¶¨Í∏∞
                if (projectile.trail.length > 1) {
                    ctx.strokeStyle = `rgba(0, 255, 136, ${projectile.life * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(projectile.trail[0].x, projectile.trail[0].y);
                    for (let i = 1; i < projectile.trail.length; i++) {
                        ctx.lineTo(projectile.trail[i].x, projectile.trail[i].y);
                    }
                    ctx.stroke();
                }

                // Ìà¨ÏÇ¨Ï≤¥ Î∞úÍ¥ë Ìö®Í≥º
                ctx.save();
                ctx.globalAlpha = projectile.life;
                ctx.shadowColor = projectile.color;
                ctx.shadowBlur = 10;
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.worldX - cameraX, projectile.worldY - cameraY, projectile.size, 0, Math.PI * 2); // worldX, worldY Í∏∞Ï§Ä
                ctx.fill();
                ctx.restore();
            });

            // ÌååÌã∞ÌÅ¥ Í∑∏Î¶¨Í∏∞
            particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x - cameraX, particle.y - cameraY, particle.size, 0, Math.PI * 2); // Ïπ¥Î©îÎùº Ïò§ÌîÑÏÖã Ï†ÅÏö©
                ctx.fill();
                ctx.restore();
            });

            // ÌñâÏÑ± Í∑∏Î¶¨Í∏∞
            planets.forEach(planet => {
                if (planet.exploded) return;
                ctx.save();
                ctx.shadowColor = `rgba(255,0,0,0.5)`;
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(planet.worldX - cameraX, planet.worldY - cameraY, planet.radius, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = `rgba(${planet.color.r|0},${planet.color.g|0},${planet.color.b|0},${planet.color.a})`;
                ctx.fill();
                ctx.restore();
            });

            // Ï≤¥Î†•Î∞î Í∑∏Î¶¨Í∏∞ (Í∞úÏÑ†Îêú Ïä§ÌÉÄÏùº)
            const healthBarWidth = 150;
            const healthBarHeight = 12;
            const healthPercentage = player.health / player.maxHealth;
            
            // HP ÎùºÎ≤®
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('HP', 17, canvas.height - 45);
            
            // Ï≤¥Î†•Î∞î Î∞∞Í≤Ω
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(15, canvas.height - 40, healthBarWidth + 4, healthBarHeight + 4);
            
            // Ï≤¥Î†•Î∞î ÌÖåÎëêÎ¶¨
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(15, canvas.height - 40, healthBarWidth + 4, healthBarHeight + 4);
            
            // Ï≤¥Î†•Î∞î ÎÇ¥Î∂Ä
            const healthGradient = ctx.createLinearGradient(17, 0, 17 + healthBarWidth, 0);
            if (healthPercentage > 0.6) {
                healthGradient.addColorStop(0, '#44ff44');
                healthGradient.addColorStop(1, '#22cc22');
            } else if (healthPercentage > 0.3) {
                healthGradient.addColorStop(0, '#ffaa44');
                healthGradient.addColorStop(1, '#ff8822');
            } else {
                healthGradient.addColorStop(0, '#ff4444');
                healthGradient.addColorStop(1, '#cc2222');
            }
            
            ctx.fillStyle = healthGradient;
            ctx.fillRect(17, canvas.height - 38, healthBarWidth * healthPercentage, healthBarHeight);

            // Í≤ΩÌóòÏπòÎ∞î Í∑∏Î¶¨Í∏∞
            const expBarWidth = 200;
            const expBarHeight = 8;
            const expPercentage = player.exp / player.expToNext;
            
            // XP ÎùºÎ≤®
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('XP', canvas.width - expBarWidth - 17, canvas.height - 30);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width - expBarWidth - 15, canvas.height - 25, expBarWidth + 4, expBarHeight + 4);
            
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(canvas.width - expBarWidth - 15, canvas.height - 25, expBarWidth + 4, expBarHeight + 4);
            
            const expGradient = ctx.createLinearGradient(canvas.width - expBarWidth - 13, 0, canvas.width - 13, 0);
            expGradient.addColorStop(0, '#4488ff');
            expGradient.addColorStop(1, '#2266cc');
            ctx.fillStyle = expGradient;
            ctx.fillRect(canvas.width - expBarWidth - 13, canvas.height - 23, expBarWidth * expPercentage, expBarHeight);
        }

        // UI ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
        function updateUI() {
            document.getElementById('health').textContent = player.health;
            document.getElementById('level').textContent = player.level;
            document.getElementById('exp').textContent = player.exp;
            document.getElementById('expMax').textContent = player.expToNext;
            document.getElementById('kills').textContent = player.kills;
            document.getElementById('completedWords').textContent = completedWords;
            document.getElementById('time').textContent = gameState.timeElapsed;
        }

        // Î†àÎ≤®ÏóÖ Ìï®Ïàò
        function levelUp() {
            player.level++;
            player.exp = 0;
            player.expToNext = Math.floor(player.expToNext * 2); // Í∏∞Ï°¥ 1.5Î∞∞ ‚Üí 2Î∞∞
            
            // Î†àÎ≤®ÏóÖ ÌååÌã∞ÌÅ¥ Ìö®Í≥º
            for (let i = 0; i < 20; i++) {
                createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'correct');
            }
            
            gameState.paused = true;
            document.getElementById('levelUpModal').style.display = 'block';
        }

        // ÏóÖÍ∑∏Î†àÏù¥Îìú ÏÑ†ÌÉù Ìï®Ïàò
        function selectUpgrade(type) {
            switch(type) {
                case 'attackSpeed':
                    player.attackSpeed = Math.max(200, player.attackSpeed * 0.8);
                    break;
                case 'moveSpeed':
                    player.speed += 0.5;
                    break;
                case 'projectileSize':
                    player.projectileSize += 1;
                    break;
                case 'health':
                    player.health = Math.min(player.maxHealth, player.health + 30);
                    break;
            }
            
            document.getElementById('levelUpModal').style.display = 'none';
            gameState.paused = false;
        }

        // Í≤åÏûÑ Ïò§Î≤Ñ Ìï®Ïàò
        function gameOver() {
            gameState.running = false;
            
            // Í≤åÏûÑ Ïò§Î≤Ñ ÌååÌã∞ÌÅ¥ Ìö®Í≥º
            for (let i = 0; i < 30; i++) {
                createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'blood');
            }
            
            document.getElementById('finalTime').textContent = gameState.timeElapsed;
            document.getElementById('finalKills').textContent = player.kills;
            document.getElementById('finalWords').textContent = completedWords;
            document.getElementById('finalLevel').textContent = player.level;
            document.getElementById('gameOver').style.display = 'block';
        }

        // Í≤åÏûÑ Ïû¨ÏãúÏûë Ìï®Ïàò
        function restartGame() {
            // Í≤åÏûÑ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
            gameState.running = true;
            gameState.paused = false;
            gameState.startTime = Date.now();
            gameState.timeElapsed = 0;

            // ÌîåÎ†àÏù¥Ïñ¥ Ï¥àÍ∏∞Ìôî
            player.worldX = worldWidth / 2;
            player.worldY = worldHeight / 2;
            player.health = 100;
            player.level = 1;
            player.exp = 0;
            player.expToNext = 10;
            player.kills = 0;
            player.speed = 3;
            player.attackSpeed = 1000;
            player.projectileSize = 6;
            player.angle = 0;

            // Í≤åÏûÑ Îç∞Ïù¥ÌÑ∞ Ï¥àÍ∏∞Ìôî
            completedWords = 0;
            selectNewWord();

            // Î∞∞Ïó¥ Ï¥àÍ∏∞Ìôî
            monsters.length = 0;
            projectiles.length = 0;
            floatingLetters.length = 0;
            particles.length = 0;
            bloodParticles.length = 0;
            planets.length = 0; // ÌñâÏÑ± Î∞∞Ïó¥ÎèÑ Ï¥àÍ∏∞Ìôî

            // UI Ï¥àÍ∏∞Ìôî
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
            // Í≤åÏûÑ ÏãúÏûë Ïãú planets ÏÉùÏÑ±
            spawnPlanets();
            // ÌîåÎ†àÏù¥Ïñ¥, Ïπ¥Î©îÎùº Ï¥àÍ∏∞Ìôî
            resetPlayerAndCamera();
        }

        // Í≤åÏûÑ Î£®ÌîÑ
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // Í≤åÏûÑ ÏãúÏûë
        selectNewWord();
        gameLoop();

        // Î≥Ñ Í∑∏Î¶¨Í∏∞ Ìï®Ïàò (ÏõêÍ±∞Î¶¨Ìòï Î™¨Ïä§ÌÑ∞Ïö©)
        function drawStar(ctx, x, y, outerRadius, innerRadius, points) {
            ctx.save();
            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const angle = (Math.PI / points) * i;
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                ctx.lineTo(
                    x + Math.cos(angle) * r,
                    y + Math.sin(angle) * r
                );
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // ÌÑ∞Ïπò/ÎßàÏö∞Ïä§ ÌÅ¥Î¶≠Ìïú ÏúÑÏπòÎ°ú Ïù¥ÎèôÌïòÎäî ÏãúÏä§ÌÖú Ï∂îÍ∞Ä
        // ÌîåÎ†àÏù¥Ïñ¥, Ïπ¥Î©îÎùº Ï¥àÍ∏∞Ìôî Ìï®Ïàò Ï∂îÍ∞Ä
        function resetPlayerAndCamera() {
            player.worldX = worldWidth / 2;
            player.worldY = worldHeight / 2;
            cameraX = player.worldX - canvas.width / 2;
            cameraY = player.worldY - canvas.height / 2;
            // Ïπ¥Î©îÎùº Í≤ΩÍ≥Ñ Î≥¥Ï†ï
            cameraX = Math.max(0, Math.min(cameraX, worldWidth - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, worldHeight - canvas.height));
        }

        // ÌÑ∞Ïπò Ïù¥Î≤§Ìä∏ (Î™®Î∞îÏùº)
        canvas.addEventListener('touchstart', function(e) {
            isPointerDown = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            pointerX = touch.clientX - rect.left + cameraX;
            pointerY = touch.clientY - rect.top + cameraY;
        });
        canvas.addEventListener('touchmove', function(e) {
            if (isPointerDown) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                pointerX = touch.clientX - rect.left + cameraX;
                pointerY = touch.clientY - rect.top + cameraY;
            }
        });
        window.addEventListener('touchend', function() {
            isPointerDown = false;
            pointerX = pointerY = null;
        });
        // ÎßàÏö∞Ïä§ ÌÅ¥Î¶≠ Ïù¥Î≤§Ìä∏ (PC)
        canvas.addEventListener('mousedown', function(e) {
            isPointerDown = true;
            const rect = canvas.getBoundingClientRect();
            pointerX = e.clientX - rect.left + cameraX;
            pointerY = e.clientY - rect.top + cameraY;
        });
        canvas.addEventListener('mousemove', function(e) {
            if (isPointerDown) {
                const rect = canvas.getBoundingClientRect();
                pointerX = e.clientX - rect.left + cameraX;
                pointerY = e.clientY - rect.top + cameraY;
            }
        });
        window.addEventListener('mouseup', function() {
            isPointerDown = false;
            pointerX = pointerY = null;
        });

        // canvas ÌÅ¨Í∏∞ Î∞òÏùëÌòï Ï°∞Ï†ï
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // Í≤åÏûÑ ÏãúÏûë ÏãúÏóêÎèÑ Ìò∏Ï∂ú
    </script>
</body>
</html>