<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ì˜ì–´ í•™ìŠµ ì„œë°”ì´ë²Œ ê²Œì„</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #0c0c0c, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
        }
        #gameContainer {
            border: 3px solid #4a90e2;
            border-radius: 10px;
            position: relative;
            box-shadow: 0 0 30px rgba(74, 144, 226, 0.5);
        }
        #gameCanvas {
            width: 100vw;
            height: 100vh;
            display: block;
            border-radius: 7px;
            background: #1a1a2e;
        }
        #wordDisplay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 25px;
            border-radius: 10px;
            border: 2px solid #ffd700;
            color: white;
            font-size: 32px;
            font-weight: bold;
            z-index: 15;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            letter-spacing: 3px;
        }
        .missing-letter {
            color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
            padding: 2px 8px;
            border-radius: 5px;
            border: 2px dashed #ff4444;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            font-size: 14px;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            font-weight: bold;
        }
        .ui-item {
            margin-bottom: 5px;
            background: rgba(0,0,0,0.7);
            padding: 3px 8px;
            border-radius: 4px;
            border-left: 2px solid #4a90e2;
            font-size: 12px;
        }
        #wordResult {
            position: fixed !important;
            left: 50% !important;
            top: 50% !important;
            transform: translate(-50%, -50%) !important;
            background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
            border: 3px solid #44ff44;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 25;
            display: none;
            box-shadow: 0 0 40px rgba(68, 255, 68, 0.6);
            max-width: 400px;
            line-height: 1.6;
        }
        .word-complete {
            font-size: 28px;
            color: #44ff44;
            margin-bottom: 15px;
        }
        .word-meaning {
            font-size: 20px;
            color: #ffffff;
            margin-bottom: 10px;
        }
        .word-pronunciation {
            font-size: 16px;
            color: #aaaaaa;
            font-style: italic;
        }
        #levelUpModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #2a2a3e, #1a1a2e);
            border: 3px solid #ffd700;
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 20;
            display: none;
            box-shadow: 0 0 40px rgba(255, 215, 0, 0.6);
        }
        .upgrade-btn {
            display: block;
            width: 320px;
            margin: 12px auto;
            padding: 12px;
            background: linear-gradient(145deg, #4a4a6a, #3a3a5a);
            border: 2px solid #666;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        .upgrade-btn:hover {
            background: linear-gradient(145deg, #5a5a7a, #4a4a6a);
            border-color: #ffd700;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #3a1a1a, #2a1a1a);
            border: 3px solid #ff4444;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            color: white;
            z-index: 20;
            display: none;
            box-shadow: 0 0 40px rgba(255, 68, 68, 0.6);
        }
        #restartBtn {
            padding: 12px 24px;
            background: linear-gradient(145deg, #ff4444, #cc3333);
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 8px;
            font-size: 16px;
            margin-top: 20px;
            font-weight: bold;
            transition: all 0.3s ease;
        }
        #restartBtn:hover {
            background: linear-gradient(145deg, #ff6666, #ff4444);
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
        }
        h2 {
            margin-top: 0;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            z-index: 25;
            pointer-events: none;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
        }
        .correct {
            color: #44ff44;
            animation: correctPulse 1s ease-out;
        }
        .incorrect {
            color: #ff4444;
            animation: incorrectShake 0.5s ease-out;
        }
        @keyframes correctPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0; }
        }
        @keyframes incorrectShake {
            0%, 100% { transform: translate(-50%, -50%); }
            25% { transform: translate(-45%, -50%); }
            75% { transform: translate(-55%, -50%); }
        }
        .correct-answer {
            color: #44ff44;
            font-size: 36px;
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 2px 2px 8px #222, 0 0 16px #44ff44;
        }
        .word-meaning {
            color: #ffd700;
            font-size: 18px;
            margin-top: 6px;
            font-weight: normal;
            text-shadow: 1px 1px 4px #222;
        }
        .word-box {
            background: rgba(20, 20, 40, 0.85);
            border: 2.5px solid #ffd700;
            border-radius: 14px;
            box-shadow: 0 4px 24px 0 rgba(0,0,0,0.35);
            padding: 18px 32px 12px 32px;
            display: inline-block;
            min-width: 180px;
            text-align: center;
            margin-top: 8px;
            margin-bottom: 8px;
            position: relative;
        }
        .word-en {
            font-family: 'Fira Mono', 'Consolas', 'monospace';
            font-size: 36px;
            color: #fff;
            letter-spacing: 4px;
            text-shadow: 0 2px 8px #222, 0 0 8px #ffd70044;
            font-weight: bold;
        }
        .missing-letter {
            color: #ff4444;
            border: none;
            border-bottom: 2.5px solid #ff4444; /* ì ì„ X, ì‹¤ì„  ì–¸ë”ë¼ì¸ë§Œ */
            background: transparent;
            margin: 0 2px;
            font-size: 36px;
            display: inline-block;
            vertical-align: baseline;
            line-height: 1;
            padding: 0 8px 2px 8px;
            border-radius: 0;
            min-width: 24px;
        }
        .word-ko {
            color: #ffe066;
            font-size: 18px;
            font-weight: 400;
            letter-spacing: 1px;
            margin-left: 18px;
            vertical-align: middle;
            text-align: left;
            border: none;
            text-shadow: none;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div id="wordDisplay">
            <span id="currentWord">appl_</span>
        </div>
        
        <div id="ui">
            <div class="ui-item">â¤ï¸ HP: <span id="health">100</span></div>
            <div class="ui-item">â­ Lv: <span id="level">1</span></div>
            <div class="ui-item">âœ¨ XP: <span id="exp">0</span>/<span id="expMax">10</span></div>
            <div class="ui-item">ğŸ’€ ì²˜ì¹˜: <span id="kills">0</span></div>
            <div class="ui-item">ğŸ“ ë‹¨ì–´: <span id="completedWords">0</span></div>
            <div class="ui-item">â±ï¸ ì‹œê°„: <span id="time">0</span>ì´ˆ</div>
        </div>
        
        <div id="feedback"></div>
        
        <div id="wordResult">
            <div class="word-complete" id="wordCompleteText">Loading...</div>
            <div class="word-meaning" id="wordMeaningText">Loading...</div>
            <div class="word-pronunciation" id="wordPronunciationText">Loading...</div>
        </div>
        
        <div id="levelUpModal">
            <h2>ğŸ‰ ë ˆë²¨ì—…! ğŸ‰</h2>
            <p>ì—…ê·¸ë ˆì´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”:</p>
            <button class="upgrade-btn" onclick="selectUpgrade('attackSpeed')">âš¡ ê³µê²© ì†ë„ ì¦ê°€ (+20%)</button>
            <button class="upgrade-btn" onclick="selectUpgrade('moveSpeed')">ğŸƒ ì´ë™ ì†ë„ ì¦ê°€ (+15%)</button>
            <button class="upgrade-btn" onclick="selectUpgrade('projectileSize')">ğŸ’¥ íˆ¬ì‚¬ì²´ í¬ê¸° ì¦ê°€ (+25%)</button>
            <button class="upgrade-btn" onclick="selectUpgrade('health')">â¤ï¸ ì²´ë ¥ íšŒë³µ (+30)</button>
        </div>
        
        <div id="gameOver">
            <h2>ğŸ’€ ê²Œì„ ì˜¤ë²„! ğŸ’€</h2>
            <p>ìƒì¡´ ì‹œê°„: <span id="finalTime">0</span>ì´ˆ</p>
            <p>ì²˜ì¹˜í•œ ëª¬ìŠ¤í„°: <span id="finalKills">0</span>ë§ˆë¦¬</p>
            <p>ì™„ì„±í•œ ë‹¨ì–´: <span id="finalWords">0</span>ê°œ</p>
            <p>ë‹¬ì„± ë ˆë²¨: <span id="finalLevel">1</span></p>
            <button id="restartBtn" onclick="restartGame()">ğŸ”„ ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <script>
        // í„°ì¹˜/ë§ˆìš°ìŠ¤ ì´ë™ ëª©í‘œ ì¢Œí‘œ ì „ì—­ ë³€ìˆ˜ ì„ ì–¸ (ê°€ì¥ ìƒë‹¨)
        let targetX = null;
        let targetY = null;

        // ë§ˆìš°ìŠ¤/í„°ì¹˜ ëˆ„ë¥´ê³  ìˆëŠ” ë™ì•ˆ ì´ë™í•˜ëŠ” ì‹œìŠ¤í…œ ë³€ìˆ˜ ì„ ì–¸
        let isPointerDown = false;
        let pointerX = null, pointerY = null;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // ì˜ì–´ ë‹¨ì–´ ë°ì´í„°ë² ì´ìŠ¤
        const wordDatabase = [
            { word: "apple", display: "appl_", missing: "e", meaning: "ì‚¬ê³¼", pronunciation: "/ËˆÃ¦p.É™l/" },
            { word: "book", display: "b_ok", missing: "o", meaning: "ì±…", pronunciation: "/bÊŠk/" },
            { word: "cat", display: "c_t", missing: "a", meaning: "ê³ ì–‘ì´", pronunciation: "/kÃ¦t/" },
            { word: "dog", display: "_og", missing: "d", meaning: "ê°œ", pronunciation: "/dÉ”ËÉ¡/" },
            { word: "fish", display: "fi_h", missing: "s", meaning: "ë¬¼ê³ ê¸°", pronunciation: "/fÉªÊƒ/" },
            { word: "house", display: "hou_e", missing: "s", meaning: "ì§‘", pronunciation: "/haÊŠs/" },
            { word: "water", display: "wat_r", missing: "e", meaning: "ë¬¼", pronunciation: "/ËˆwÉ”Ë.tÉ™r/" },
            { word: "tree", display: "tr_e", missing: "e", meaning: "ë‚˜ë¬´", pronunciation: "/triË/" },
            { word: "bird", display: "b_rd", missing: "i", meaning: "ìƒˆ", pronunciation: "/bÉœËrd/" },
            { word: "moon", display: "m_on", missing: "o", meaning: "ë‹¬", pronunciation: "/muËn/" },
            { word: "star", display: "st_r", missing: "a", meaning: "ë³„", pronunciation: "/stÉ‘Ër/" },
            { word: "flower", display: "flow_r", missing: "e", meaning: "ê½ƒ", pronunciation: "/ËˆflaÊŠ.É™r/" },
            { word: "music", display: "mu_ic", missing: "s", meaning: "ìŒì•…", pronunciation: "/ËˆmjuË.zÉªk/" },
            { word: "friend", display: "fri_nd", missing: "e", meaning: "ì¹œêµ¬", pronunciation: "/frend/" },
            { word: "happy", display: "hap_y", missing: "p", meaning: "í–‰ë³µí•œ", pronunciation: "/ËˆhÃ¦p.i/" }
        ];

        // í˜„ì¬ ë‹¨ì–´ ìƒíƒœ
        let currentWordData = wordDatabase[0];
        let completedWords = 0;

        // íŒŒí‹°í´ ì‹œìŠ¤í…œ
        const particles = [];
        const bloodParticles = [];

        // ë°°ê²½ ë³„ë“¤
        const stars = [];
        for (let i = 0; i < 100; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                twinkle: Math.random() * Math.PI * 2,
                speed: Math.random() * 0.02 + 0.01
            });
        }

        // ê²Œì„ ìƒíƒœ
        let gameState = {
            running: true,
            paused: false,
            startTime: Date.now(),
            timeElapsed: 0
        };

        // ì›”ë“œ í¬ê¸° ë° ì¹´ë©”ë¼ ë³€ìˆ˜ ì¶”ê°€
        const worldWidth = 3000;
        const worldHeight = 3000;
        let cameraX = 0;
        let cameraY = 0;

        // í”Œë ˆì´ì–´ ê°ì²´ì— ì›”ë“œ ì¢Œí‘œ ì¶”ê°€
        const player = {
            worldX: worldWidth / 2,
            worldY: worldHeight / 2,
            width: 24,
            height: 24,
            speed: 3,
            health: 100,
            maxHealth: 100,
            level: 1,
            exp: 0,
            expToNext: 10,
            kills: 0,
            attackSpeed: 1000,
            lastAttack: 0,
            projectileSize: 6,
            angle: 0
        };

        // ì…ë ¥ ìƒíƒœ
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        // ê²Œì„ ì˜¤ë¸Œì íŠ¸ ë°°ì—´
        const monsters = [];
        const projectiles = [];
        const floatingLetters = []; // ë– ë‹¤ë‹ˆëŠ” ì•ŒíŒŒë²³ë“¤

        // ëª¬ìŠ¤í„° íƒ€ì… ë°ì´í„° êµ¬ì¡° (ì™¸í˜•, ìƒ‰ìƒ, í¬ê¸°)
        const monsterTypes = [
            { name: 'basic', color: '#ff4444', speed: 1, size: 18, health: 1, shape: 'rect' }, // ê¸°ë³¸í˜•: ë¹¨ê°„ ì‚¬ê°í˜•
            { name: 'fast', color: '#44ff44', speed: 1.8, size: 14, health: 0.7, shape: 'triangle' }, // ë¹ ë¥¸í˜•: ì´ˆë¡ ì‚¼ê°í˜•
            { name: 'tank', color: '#4444ff', speed: 0.7, size: 26, health: 3, shape: 'circle' }, // íƒ±ì»¤í˜•: íŒŒë€ ì›
            { name: 'ranged', color: '#ffaa00', speed: 1, size: 16, health: 1, shape: 'star', shootInterval: 2000 }, // ì›ê±°ë¦¬í˜•: ë…¸ë€ ë³„
            { name: 'splitter', color: '#ff44aa', speed: 1, size: 18, health: 1, shape: 'rect' }, // ë¶„ì—´í˜•: ë¶„í™ ì‚¬ê°í˜•
            { name: 'exploder', color: '#ff8800', speed: 1.2, size: 16, health: 1, shape: 'circle' }, // í­ë°œí˜•: ì£¼í™© ì›
            { name: 'dodger', color: '#00ffff', speed: 1.1, size: 16, health: 1, shape: 'triangle' }, // íšŒí”¼í˜•: í•˜ëŠ˜ ì‚¼ê°í˜•
        ];

        // ì‹œê°„ ê²½ê³¼ì— ë”°ë¼ ë“±ì¥í•˜ëŠ” ëª¬ìŠ¤í„° íƒ€ì… ê²°ì • í•¨ìˆ˜
        function getAvailableMonsterTypes(timeElapsed) {
            if (timeElapsed < 30) return ['basic', 'fast'];
            if (timeElapsed < 60) return ['basic', 'fast', 'tank', 'splitter'];
            if (timeElapsed < 90) return ['basic', 'fast', 'tank', 'splitter', 'ranged', 'exploder'];
            return ['basic', 'fast', 'tank', 'splitter', 'ranged', 'exploder', 'dodger'];
        }

        // ëª¬ìŠ¤í„° ìŠ¤í° ê´€ë ¨
        let lastMonsterSpawn = 0;
        let monsterSpawnRate = 500; // 0.5ì´ˆë§ˆë‹¤ ëª¬ìŠ¤í„° ìŠ¤í° (2ë°° ë¹ ë¥´ê²Œ)

        // ì•ŒíŒŒë²³ ìŠ¤í° ê´€ë ¨
        let lastLetterSpawn = 0;
        let letterSpawnRate = 62; // 0.062ì´ˆë§ˆë‹¤ ì•ŒíŒŒë²³ ìŠ¤í° (2ë°° ë” ë¹ ë¥´ê²Œ)

        // ì›”ë“œ í–‰ì„±(ë³„) ë°°ì—´ ì¶”ê°€
        const planets = [];
        // ê²Œì„ ì‹œì‘ ì‹œ í–‰ì„± ì—¬ëŸ¬ ê°œ ìƒì„±
        function spawnPlanets() {
            const planetCount = 5 + Math.floor(Math.random() * 4); // 5~8ê°œ
            for (let i = 0; i < planetCount; i++) {
                const radius = 40 + Math.random() * 60; // í¬ê¸° ë‹¤ì–‘(40~100)
                const worldX = 200 + Math.random() * (worldWidth - 400);
                const worldY = 200 + Math.random() * (worldHeight - 400);
                const color = {r: 120 + Math.random()*80, g: 120 + Math.random()*80, b: 200, a: 1};
                planets.push({
                    worldX, worldY, radius, color, timer: 0, exploded: false
                });
            }
        }

        // ì•ŒíŒŒë²³ ë°°ì—´
        const alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');

        // í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
        });

        document.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        });

        // ìƒˆë¡œìš´ ë‹¨ì–´ ì„ íƒ í•¨ìˆ˜
        function selectNewWord() {
            currentWordData = wordDatabase[Math.floor(Math.random() * wordDatabase.length)];
            // '_' ë¬¸ì ì—†ì´, missing-letterë§Œ ë‚¨ê¸°ê¸°
            const display = currentWordData.display.replace('_', '<span class="missing-letter">&nbsp;</span>');
            document.getElementById('wordDisplay').innerHTML = `
                <span class="word-en">${display}</span><span class="word-ko">${currentWordData.meaning}</span>
            `;
        }

        // ë‹¨ì–´ ì™„ì„± ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        function showWordResult(wordData) {
            console.log('showWordResult called with:', wordData);
            
            const wordCompleteElement = document.getElementById('wordCompleteText');
            const wordMeaningElement = document.getElementById('wordMeaningText');
            const wordPronunciationElement = document.getElementById('wordPronunciationText');
            const wordResultElement = document.getElementById('wordResult');
            
            console.log('Found elements:', {
                wordComplete: wordCompleteElement,
                wordMeaning: wordMeaningElement,
                wordPronunciation: wordPronunciationElement,
                wordResult: wordResultElement
            });
            
            if (wordCompleteElement && wordMeaningElement && wordPronunciationElement && wordResultElement) {
                console.log('All elements found, showing result');
                
                wordCompleteElement.textContent = `âœ¨ ${wordData.word.toUpperCase()} âœ¨`;
                wordMeaningElement.textContent = `ëœ»: ${wordData.meaning}`;
                wordPronunciationElement.textContent = `ë°œìŒ: ${wordData.pronunciation}`;
                
                wordResultElement.style.display = 'block';
                
                // ë‹¨ì–´ ìŒì„± ì½ê¸°
                if ('speechSynthesis' in window) {
                    speechSynthesis.cancel();
                    
                    setTimeout(() => {
                        const utterance = new SpeechSynthesisUtterance(wordData.word);
                        utterance.lang = 'en-US';
                        utterance.rate = 0.8;
                        utterance.volume = 1.0;
                        
                        utterance.onstart = () => console.log('ìŒì„± ì‹œì‘:', wordData.word);
                        utterance.onend = () => console.log('ìŒì„± ì¢…ë£Œ');
                        utterance.onerror = (event) => console.log('ìŒì„± ì˜¤ë¥˜:', event.error);
                        
                        speechSynthesis.speak(utterance);
                    }, 200);
                }
                
                setTimeout(() => {
                    wordResultElement.style.display = 'none';
                }, 3000);
            } else {
                console.log('Elements not found, using fallback');
                showFeedback(`${wordData.word} (${wordData.meaning})`, true);
            }
        }

        // í”¼ë“œë°± í‘œì‹œ í•¨ìˆ˜
        function showFeedback(text, isCorrect) {
            const feedback = document.getElementById('feedback');
            feedback.textContent = text;
            feedback.className = isCorrect ? 'correct' : 'incorrect';
            feedback.style.display = 'block';
            
            setTimeout(() => {
                feedback.style.display = 'none';
            }, 1000);
        }

        // íŒŒí‹°í´ ìƒì„± í•¨ìˆ˜
        function createParticle(x, y, type = 'normal') {
            const particle = {
                x: x,
                y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: (Math.random() - 0.5) * 4,
                life: 1,
                decay: Math.random() * 0.02 + 0.01,
                size: Math.random() * 3 + 1,
                type: type
            };

            if (type === 'blood') {
                particle.color = `hsl(${Math.random() * 30}, 100%, ${Math.random() * 30 + 40}%)`;
                bloodParticles.push(particle);
            } else if (type === 'correct') {
                particle.color = `hsl(120, 100%, ${Math.random() * 30 + 50}%)`;
                particles.push(particle);
            } else {
                particle.color = `hsl(${Math.random() * 60 + 180}, 100%, 70%)`;
                particles.push(particle);
            }
        }

        // ëª¬ìŠ¤í„° ìƒì„± í•¨ìˆ˜ (íƒ€ì…ë³„ë¡œ ìƒì„±)
        function createMonster() {
            const availableTypes = getAvailableMonsterTypes(gameState.timeElapsed);
            const typeName = availableTypes[Math.floor(Math.random() * availableTypes.length)];
            const type = monsterTypes.find(t => t.name === typeName);

            // ëª¬ìŠ¤í„° ìœ„ì¹˜ ëœë¤ ìƒì„± (ê¸°ì¡´ ì½”ë“œ ìœ ì§€)
            const side = Math.floor(Math.random() * 4);
            let x, y;
            switch(side) {
                case 0: x = Math.random() * canvas.width; y = -30; break;
                case 1: x = canvas.width + 30; y = Math.random() * canvas.height; break;
                case 2: x = Math.random() * canvas.width; y = canvas.height + 30; break;
                case 3: x = -30; y = Math.random() * canvas.height; break;
            }

            // ëª¬ìŠ¤í„°, ì•ŒíŒŒë²³ ë“± ì˜¤ë¸Œì íŠ¸ ìƒì„± ì‹œ worldX, worldY ì‚¬ìš©
            monsters.push({
                worldX: x, // ê¸°ì¡´ x â†’ worldX
                worldY: y, // ê¸°ì¡´ y â†’ worldY
                width: type.size,
                height: type.size,
                speed: type.speed + Math.random() * 0.3,
                health: type.health,
                color: type.color,
                angle: 0,
                pulse: Math.random() * Math.PI * 2,
                name: type.name,
                shape: type.shape,
                shootInterval: type.shootInterval || null,
                lastShot: 0,
                // íŠ¹ìˆ˜ ëª¬ìŠ¤í„°ìš© ì†ì„±
                splitChild: false, // ë¶„ì—´í˜• ìì‹ ì—¬ë¶€
                exploded: false,   // í­ë°œí˜• ìí­ ì—¬ë¶€
                dodgeCooldown: 0   // íšŒí”¼í˜• ì¿¨íƒ€ì„
            });
        }

        // ë– ë‹¤ë‹ˆëŠ” ì•ŒíŒŒë²³ ìƒì„± í•¨ìˆ˜
        function createFloatingLetter() {
            // ëœë¤ ì•ŒíŒŒë²³ ì„ íƒ (ì •ë‹µ ì•ŒíŒŒë²³ì´ ë” ìì£¼ ë‚˜ì˜¤ë„ë¡ â†’ ì˜¤ë‹µ í™•ë¥  ë†’ì„)
            let letter;
            if (Math.random() < 0.3) { // 30% í™•ë¥ ë¡œ ì •ë‹µ
                letter = currentWordData.missing;
            } else { // 70% í™•ë¥ ë¡œ ëœë¤ ì˜¤ë‹µ ì•ŒíŒŒë²³
                // ì •ë‹µì´ ì•„ë‹Œ ì•ŒíŒŒë²³ë§Œ ë½‘ê¸°
                let wrongs = alphabet.filter(a => a !== currentWordData.missing);
                letter = wrongs[Math.floor(Math.random() * wrongs.length)];
            }

            const isCorrect = letter === currentWordData.missing;

            // í™”ë©´ ìœ„ìª½ì—ì„œ ì‹œì‘í•´ì„œ ì•„ë˜ë¡œ ì´ë™ - ëª¨ë“  ì•ŒíŒŒë²³ ë™ì¼í•œ ìƒ‰ìƒ
            floatingLetters.push({
                worldX: Math.random() * (canvas.width - 40) + 20, // í™”ë©´ ì¢Œí‘œ â†’ ì›”ë“œ ì¢Œí‘œ
                worldY: -30, // í™”ë©´ ì¢Œí‘œ â†’ ì›”ë“œ ì¢Œí‘œ
                width: 30,
                height: 30,
                vx: (Math.random() - 0.5) * 2, // ì¢Œìš°ë¡œ ì•½ê°„ í”ë“¤ë¦¼
                vy: 1.5 + Math.random() * 1, // ì•„ë˜ë¡œ ì´ë™ ì†ë„
                letter: letter,
                isCorrect: isCorrect,
                color: '#66aaff', // ëª¨ë“  ì•ŒíŒŒë²³ ë™ì¼í•œ íŒŒë€ìƒ‰
                pulse: Math.random() * Math.PI * 2,
                collected: false
            });
        }

        // íˆ¬ì‚¬ì²´ ìƒì„± í•¨ìˆ˜
        function createProjectile() {
            if (monsters.length === 0) return;

            // ê°€ì¥ ê°€ê¹Œìš´ ëª¬ìŠ¤í„° ì°¾ê¸°
            let nearestMonster = monsters[0];
            let minDistance = Infinity;

            monsters.forEach(monster => {
                const dx = monster.worldX - player.worldX; // worldX ê¸°ì¤€
                const dy = monster.worldY - player.worldY; // worldY ê¸°ì¤€
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestMonster = monster;
                }
            });

            // íˆ¬ì‚¬ì²´ ìƒì„±
            const dx = nearestMonster.worldX - player.worldX; // worldX ê¸°ì¤€
            const dy = nearestMonster.worldY - player.worldY; // worldY ê¸°ì¤€
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            projectiles.push({
                worldX: player.worldX + player.width / 2, // worldX ê¸°ì¤€
                worldY: player.worldY + player.height / 2, // worldY ê¸°ì¤€
                vx: (dx / distance) * 6,
                vy: (dy / distance) * 6,
                size: player.projectileSize,
                color: '#00ff88',
                trail: [],
                life: 1
            });
        }

        // ì¶©ëŒ ê°ì§€ í•¨ìˆ˜
        function checkCollision(rect1, rect2) {
            return rect1.worldX < rect2.worldX + rect2.width &&
                   rect1.worldX + rect1.width > rect2.worldX &&
                   rect1.worldY < rect2.worldY + rect2.height &&
                   rect1.worldY + rect1.height > rect2.worldY;
        }

        // ì›ê³¼ ì‚¬ê°í˜• ì¶©ëŒ ê°ì§€
        function checkCircleRectCollision(circle, rect) {
            const dx = circle.worldX - Math.max(rect.worldX, Math.min(circle.worldX, rect.worldX + rect.width)); // worldX ê¸°ì¤€
            const dy = circle.worldY - Math.max(rect.worldY, Math.min(circle.worldY, rect.worldY + rect.height)); // worldY ê¸°ì¤€
            return (dx * dx + dy * dy) < (circle.size * circle.size);
        }

        // ê²Œì„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function update() {
            if (!gameState.running || gameState.paused) return;

            const currentTime = Date.now();
            gameState.timeElapsed = Math.floor((currentTime - gameState.startTime) / 1000);

            // í”Œë ˆì´ì–´ ì´ë™ ë° ê°ë„ ì—…ë°ì´íŠ¸
            let moving = false;
            if (keys.w && player.worldY > 0) {
                player.worldY -= player.speed;
                moving = true;
            }
            if (keys.s && player.worldY < worldHeight - player.height) {
                player.worldY += player.speed;
                moving = true;
            }
            if (keys.a && player.worldX > 0) {
                player.worldX -= player.speed;
                moving = true;
            }
            if (keys.d && player.worldX < worldWidth - player.width) {
                player.worldX += player.speed;
                moving = true;
            }

            // í„°ì¹˜/ë§ˆìš°ìŠ¤ ëˆ„ë¥´ê³  ìˆëŠ” ë™ì•ˆ ì´ë™í•˜ëŠ” ì‹œìŠ¤í…œ ë¡œì§ ìˆ˜ì •
            if (isPointerDown && pointerX !== null && pointerY !== null) {
                const dx = pointerX - (player.worldX + player.width/2);
                const dy = pointerY - (player.worldY + player.height/2);
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 4) {
                    player.worldX += (dx / dist) * player.speed;
                    player.worldY += (dy / dist) * player.speed;
                    moving = true;
                }
            }

            if (moving) {
                player.angle += 0.2;
                if (Math.random() < 0.3) {
                    createParticle(player.worldX + player.width/2, player.worldY + player.height, 'normal');
                }
            }

            // ë³„ ê¹œë¹¡ì„ ì—…ë°ì´íŠ¸
            stars.forEach(star => {
                star.twinkle += star.speed;
            });

            // ëª¬ìŠ¤í„° ìŠ¤í°
            if (currentTime - lastMonsterSpawn > monsterSpawnRate) {
                createMonster();
                lastMonsterSpawn = currentTime;
                // 30ì´ˆë§ˆë‹¤ ìŠ¤í° ì†ë„ ì¦ê°€, ìµœì†Œ 200ms
                monsterSpawnRate = Math.max(200, 500 - Math.floor(gameState.timeElapsed / 30) * 75);
            }

            // ì•ŒíŒŒë²³ ìŠ¤í°
            if (currentTime - lastLetterSpawn > letterSpawnRate) {
                createFloatingLetter();
                lastLetterSpawn = currentTime;
                // 30ì´ˆë§ˆë‹¤ ìŠ¤í° ì†ë„ ì¦ê°€, ìµœì†Œ 30ms
                letterSpawnRate = Math.max(30, 62 - Math.floor(gameState.timeElapsed / 30) * 12);
            }

            // íˆ¬ì‚¬ì²´ ë°œì‚¬
            if (currentTime - player.lastAttack > player.attackSpeed) {
                createProjectile();
                player.lastAttack = currentTime;
            }

            // ëª¬ìŠ¤í„° ì—…ë°ì´íŠ¸ (ê¸°ì¡´ê³¼ ë™ì¼)
            for (let i = monsters.length - 1; i >= 0; i--) {
                const monster = monsters[i];
                const dx = player.worldX - monster.worldX; // worldX ê¸°ì¤€
                const dy = player.worldY - monster.worldY; // worldY ê¸°ì¤€
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // í­ë°œí˜•: í”Œë ˆì´ì–´ ê·¼ì²˜ì—ì„œ ìí­
                if (monster.name === 'exploder' && !monster.exploded && distance < 40) {
                    // ìí­ íŒŒí‹°í´ íš¨ê³¼
                    for (let j = 0; j < 18; j++) {
                        createParticle(monster.worldX + monster.width/2, monster.worldY + monster.height/2, 'blood');
                    }
                    // í”Œë ˆì´ì–´ ë°ë¯¸ì§€
                    player.health -= 20;
                    monster.exploded = true;
                    monsters.splice(i, 1);
                    if (player.health <= 0) gameOver();
                    continue;
                }

                // íšŒí”¼í˜•: íˆ¬ì‚¬ì²´ ì ‘ê·¼ ì‹œ ìˆœê°„ ì´ë™(ì¿¨íƒ€ì„ 2ì´ˆ)
                if (monster.name === 'dodger') {
                    if (monster.dodgeCooldown > 0) monster.dodgeCooldown--;
                    for (const proj of projectiles) {
                        const pdx = proj.worldX - (monster.worldX + monster.width/2); // worldX ê¸°ì¤€
                        const pdy = proj.worldY - (monster.worldY + monster.height/2); // worldY ê¸°ì¤€
                        const pdist = Math.sqrt(pdx * pdx + pdy * pdy);
                        if (pdist < 60 && monster.dodgeCooldown === 0) {
                            // ìˆœê°„ ì´ë™(ë§µ ë‚´ ëœë¤ ìœ„ì¹˜)
                            monster.worldX = Math.random() * (worldWidth - monster.width); // worldX ê¸°ì¤€
                            monster.worldY = Math.random() * (worldHeight - monster.height); // worldY ê¸°ì¤€
                            monster.dodgeCooldown = 120; // 2ì´ˆ(60fps ê¸°ì¤€)
                            break;
                        }
                    }
                }

                // ê¸°ì¡´ ì´ë™/ì¶©ëŒ ì½”ë“œ
                monster.worldX += (dx / distance) * monster.speed; // worldX ê¸°ì¤€
                monster.worldY += (dy / distance) * monster.speed; // worldY ê¸°ì¤€
                monster.angle += 0.1;
                monster.pulse += 0.15;

                // í”Œë ˆì´ì–´ì™€ ëª¬ìŠ¤í„° ì¶©ëŒ
                if (checkCollision(player, monster)) {
                    player.health -= 10;
                    // í˜ˆí” íŒŒí‹°í´ ìƒì„±
                    for (let j = 0; j < 8; j++) {
                        createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'blood');
                    }
                    monsters.splice(i, 1);
                    
                    if (player.health <= 0) {
                        gameOver();
                    }
                }

                // ë¶„ì—´í˜•: ì£½ì„ ë•Œ ì‘ì€ ëª¬ìŠ¤í„° ì—¬ëŸ¬ ë§ˆë¦¬ ìƒì„±
                if (monster.name === 'splitter' && monster.health <= 0 && !monster.splitChild) {
                    for (let k = 0; k < 2 + Math.floor(Math.random() * 2); k++) {
                        monsters.push({
                            worldX: monster.worldX + Math.random() * 20 - 10, // worldX ê¸°ì¤€
                            worldY: monster.worldY + Math.random() * 20 - 10, // worldY ê¸°ì¤€
                            width: 12,
                            height: 12,
                            speed: 1.5,
                            health: 0.5,
                            color: '#ff99ee',
                            angle: 0,
                            pulse: Math.random() * Math.PI * 2,
                            name: 'basic',
                            shape: 'rect',
                            splitChild: true,
                            exploded: false,
                            dodgeCooldown: 0
                        });
                    }
                    monsters.splice(i, 1);
                    continue;
                }

                // ëª¬ìŠ¤í„° ì‚¬ë§ ì²˜ë¦¬ ë¶€ë¶„ì—ì„œ íŒŒí‹°í´ íš¨ê³¼ë¥¼ ëª¨ë“  íƒ€ì…ì— ê³µí†µ ì ìš©
                if (monster.health <= 0) {
                    // íŒŒí‹°í´ íš¨ê³¼ (ëª¨ë“  ëª¬ìŠ¤í„° ê³µí†µ)
                    for (let i = 0; i < 12; i++) {
                        createParticle(monster.worldX + monster.width/2, monster.worldY + monster.height/2, 'blood');
                    }
                    monsters.splice(i, 1);
                    // ëª¬ìŠ¤í„° ì²˜ì¹˜ ì‹œ ê²½í—˜ì¹˜ 1ë¡œ ê°ì†Œ
                    player.kills++;
                    player.exp += 1;
                    if (player.exp >= player.expToNext) levelUp();
                }
            }

            // ë– ë‹¤ë‹ˆëŠ” ì•ŒíŒŒë²³ ì—…ë°ì´íŠ¸
            floatingLetters.forEach(letter => {
                if (!letter.collected) {
                    letter.worldX += letter.vx; // worldX ê¸°ì¤€
                    letter.worldY += letter.vy; // worldY ê¸°ì¤€
                    letter.pulse += 0.1;

                    // í”Œë ˆì´ì–´ì™€ ì•ŒíŒŒë²³ ì¶©ëŒ
                    if (checkCollision(player, letter)) {
                        letter.collected = true;
                        
                        // ì •ë‹µ ë§ì¶œ ë•Œ ë¬¸ì œ ì˜ì—­ì— ì •ë‹µ í”¼ë“œë°± í‘œì‹œ, ì¼ì • ì‹œê°„ í›„ ë‹¤ìŒ ë¬¸ì œë¡œ ì „í™˜
                        if (letter.isCorrect) {
                            completedWords++;
                            showFeedback(`ì •ë‹µ!`, true);
                            // í™”ë©´ ìƒë‹¨ ë¬¸ì œ ì˜ì—­ì— ì •ë‹µ í‘œì‹œ
                            const wordDisplay = document.getElementById('wordDisplay');
                            wordDisplay.innerHTML = `<span class='correct-answer'>ì •ë‹µ! ${currentWordData.word.toUpperCase()}</span>`;
                            // ì •ë‹µ ë‹¨ì–´ ìŒì„± ì¶œë ¥
                            if ('speechSynthesis' in window) {
                                speechSynthesis.cancel();
                                setTimeout(() => {
                                    const utterance = new SpeechSynthesisUtterance(currentWordData.word);
                                    utterance.lang = 'en-US';
                                    utterance.rate = 0.8;
                                    utterance.volume = 1.0;
                                    speechSynthesis.speak(utterance);
                                }, 200);
                            }
                            // ì„±ê³µ íŒŒí‹°í´
                            for (let i = 0; i < 15; i++) {
                                createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'correct');
                            }
                            // ê²½í—˜ì¹˜ ë³´ìƒ (ë ˆë²¨ Ã— 10)
                            player.exp += player.level * 10;
                            if (player.exp >= player.expToNext) levelUp();
                            // ëª¨ë“  ì•ŒíŒŒë²³ í­ë°œ (ë°ë¯¸ì§€ ì—†ì´ íŒŒí‹°í´ë§Œ)
                            floatingLetters.forEach(fl => {
                                for (let j = 0; j < 10; j++) {
                                    const angle = Math.random() * Math.PI * 2;
                                    const dist = 10 + Math.random() * 20;
                                    createParticle(
                                        fl.worldX + fl.width/2 + Math.cos(angle) * dist,
                                        fl.worldY + fl.height/2 + Math.sin(angle) * dist,
                                        'blood'
                                    );
                                }
                                fl.collected = true;
                            });
                            // 2ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œë¡œ ì „í™˜
                            setTimeout(() => {
                                selectNewWord();
                            }, 2000);
                            return;
                        } else {
                            // í‹€ë¦° ì•ŒíŒŒë²³
                            player.health -= 15;
                            showFeedback(`í‹€ë ¸ìŠµë‹ˆë‹¤! ${letter.letter}`, false);
                            
                            // ë°ë¯¸ì§€ íŒŒí‹°í´
                            for (let i = 0; i < 8; i++) {
                                createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'blood');
                            }
                            
                            if (player.health <= 0) {
                                gameOver();
                            }
                        }
                    }

                    // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°„ ì•ŒíŒŒë²³ ì œê±°
                    if (letter.worldY > worldHeight + 50) { // worldY ê¸°ì¤€
                        letter.collected = true;
                    }
                }
            });

            // ìˆ˜ì§‘ëœ ì•ŒíŒŒë²³ ì œê±°
            floatingLetters.splice(0, floatingLetters.length, ...floatingLetters.filter(letter => !letter.collected));

            // íˆ¬ì‚¬ì²´ ì—…ë°ì´íŠ¸
            projectiles.forEach(projectile => {
                // íŠ¸ë ˆì¼ ì¶”ê°€
                projectile.trail.push({x: projectile.worldX, y: projectile.worldY}); // worldX, worldY ê¸°ì¤€
                if (projectile.trail.length > 8) {
                    projectile.trail.shift();
                }

                projectile.worldX += projectile.vx; // worldX ê¸°ì¤€
                projectile.worldY += projectile.vy; // worldY ê¸°ì¤€
                projectile.life -= 0.01;

                // íˆ¬ì‚¬ì²´ì™€ ëª¬ìŠ¤í„° ì¶©ëŒ
                monsters.forEach(monster => {
                    if (checkCircleRectCollision(projectile, monster)) {
                        // ëª¬ìŠ¤í„° ì²˜ì¹˜ íŒŒí‹°í´
                        for (let i = 0; i < 12; i++) {
                            createParticle(monster.worldX + monster.width/2, monster.worldY + monster.height/2, 'blood');
                        }
                        
                        monster.health -= 1; // ëª¬ìŠ¤í„° ì²˜ì¹˜ ì‹œ health ê°ì†Œ
                        if (monster.health <= 0) {
                            player.kills++;
                            player.exp += 1;
                            if (player.exp >= player.expToNext) levelUp();
                        }
                        projectiles.splice(projectiles.indexOf(projectile), 1);
                    }
                });

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ê±°ë‚˜ ìˆ˜ëª…ì´ ë‹¤í•œ íˆ¬ì‚¬ì²´ ì œê±°
                if (projectile.worldX < -50 || projectile.worldX > worldWidth + 50 || 
                    projectile.worldY < -50 || projectile.worldY > worldHeight + 50 || 
                    projectile.life <= 0) {
                    projectiles.splice(projectiles.indexOf(projectile), 1);
                }
            });

            // íŒŒí‹°í´ ì—…ë°ì´íŠ¸
            particles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                particle.life -= particle.decay;
            });
            
            bloodParticles.forEach(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.vx *= 0.95;
                particle.vy *= 0.95;
                particle.vy += 0.1;
                particle.life -= particle.decay;
            });

            // ì£½ì€ íŒŒí‹°í´ ì œê±°
            particles.splice(0, particles.length, ...particles.filter(p => p.life > 0));
            bloodParticles.splice(0, bloodParticles.length, ...bloodParticles.filter(p => p.life > 0));

            // í–‰ì„± íƒ€ì´ë¨¸, ìƒ‰ìƒ ë³€í™”, í­ë°œ ì²˜ë¦¬
            planets.forEach(planet => {
                if (planet.exploded) return;
                planet.timer += 1; // í”„ë ˆì„ ë‹¨ìœ„(60í”„ë ˆì„=1ì´ˆ)
                // 20ì´ˆ(1200í”„ë ˆì„)ê¹Œì§€ ì ì  ë¶‰ì–´ì§
                const t = Math.min(planet.timer / 1200, 1);
                planet.color.r = 120 + t * 120; // r: 120~240
                planet.color.g = 120 * (1-t) + 30 * t; // g: 120~30
                planet.color.b = 200 * (1-t) + 30 * t; // b: 200~30
                // í­ë°œ
                if (planet.timer >= 1200) {
                    planet.exploded = true;
                    // í­ë°œ íŒŒí‹°í´ íš¨ê³¼
                    for (let i = 0; i < 40; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const dist = planet.radius + Math.random() * 40;
                        createParticle(
                            planet.worldX + Math.cos(angle) * dist,
                            planet.worldY + Math.sin(angle) * dist,
                            'blood'
                        );
                    }
                    // í­ë°œ ë°˜ê²½ ë‚´ í”Œë ˆì´ì–´/ëª¬ìŠ¤í„° ëŒ€ë¯¸ì§€
                    const explosionRadius = planet.radius + 120;
                    // í”Œë ˆì´ì–´
                    const pdx = player.worldX + player.width/2 - planet.worldX;
                    const pdy = player.worldY + player.height/2 - planet.worldY;
                    if (Math.sqrt(pdx*pdx + pdy*pdy) < explosionRadius) {
                        player.health -= 40;
                        if (player.health <= 0) gameOver();
                    }
                    // ëª¬ìŠ¤í„°
                    for (let i = monsters.length - 1; i >= 0; i--) {
                        const m = monsters[i];
                        const mdx = m.worldX + m.width/2 - planet.worldX;
                        const mdy = m.worldY + m.height/2 - planet.worldY;
                        if (Math.sqrt(mdx*mdx + mdy*mdy) < explosionRadius) {
                            monsters.splice(i, 1);
                        }
                    }
                }
            });

            // ì¹´ë©”ë¼ ëª©í‘œ ìœ„ì¹˜ ê³„ì‚°
            const targetCameraX = player.worldX - canvas.width / 2;
            const targetCameraY = player.worldY - canvas.height / 2;
            // lerp(ë³´ê°„)ìœ¼ë¡œ ë¶€ë“œëŸ½ê²Œ ì´ë™
            cameraX += (targetCameraX - cameraX) * 0.1;
            cameraY += (targetCameraY - cameraY) * 0.1;
            // ë§µ ê²½ê³„ì—ì„œ ì¹´ë©”ë¼ê°€ ë²—ì–´ë‚˜ì§€ ì•Šë„ë¡ ë³´ì •
            cameraX = Math.max(0, Math.min(cameraX, worldWidth - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, worldHeight - canvas.height));

            updateUI();
        }

        // ë Œë”ë§ í•¨ìˆ˜
        function render() {
            // ë°°ê²½ ê·¸ë¼ë””ì–¸íŠ¸
            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width);
            gradient.addColorStop(0, '#1a1a2e');
            gradient.addColorStop(0.5, '#16213e');
            gradient.addColorStop(1, '#0f1419');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ë³„ ê·¸ë¦¬ê¸°
            stars.forEach(star => {
                const alpha = (Math.sin(star.twinkle) + 1) / 2;
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // í˜ˆí” íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            bloodParticles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x - cameraX, particle.y - cameraY, particle.size, 0, Math.PI * 2); // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
                ctx.fill();
                ctx.restore();
            });

            // í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸° (ë°œê´‘ íš¨ê³¼)
            ctx.save();
            ctx.shadowColor = '#4499ff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#4499ff';
            ctx.translate(player.worldX - cameraX, player.worldY - cameraY); // worldX, worldY ê¸°ì¤€
            ctx.rotate(player.angle);
            ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
            ctx.restore();

            // í”Œë ˆì´ì–´ ì¤‘ì‹¬ì 
            ctx.fillStyle = '#88ccff';
            ctx.beginPath();
            ctx.arc(player.worldX - cameraX, player.worldY - cameraY, 3, 0, Math.PI * 2); // worldX, worldY ê¸°ì¤€
            ctx.fill();

            // ëª¬ìŠ¤í„° ê·¸ë¦¬ê¸° (íƒ€ì…ë³„ ì™¸í˜•)
            monsters.forEach(monster => {
                const pulse = Math.sin(monster.pulse) * 0.2 + 1;
                ctx.save();
                ctx.shadowColor = monster.color;
                ctx.shadowBlur = 10;
                ctx.fillStyle = monster.color;
                ctx.translate(monster.worldX - cameraX, monster.worldY - cameraY); // worldX, worldY ê¸°ì¤€
                ctx.rotate(monster.angle);
                ctx.scale(pulse, pulse);
                // íƒ€ì…ë³„ë¡œ ë„í˜• ë‹¤ë¥´ê²Œ ê·¸ë¦¬ê¸°
                if (monster.shape === 'rect') {
                    // ì‚¬ê°í˜•
                    ctx.fillRect(-monster.width/2, -monster.height/2, monster.width, monster.height);
                } else if (monster.shape === 'circle') {
                    // ì›
                    ctx.beginPath();
                    ctx.arc(0, 0, monster.width/2, 0, Math.PI * 2);
                    ctx.fill();
                } else if (monster.shape === 'triangle') {
                    // ì‚¼ê°í˜•
                    ctx.beginPath();
                    ctx.moveTo(0, -monster.width/2);
                    ctx.lineTo(-monster.width/2, monster.width/2);
                    ctx.lineTo(monster.width/2, monster.width/2);
                    ctx.closePath();
                    ctx.fill();
                } else if (monster.shape === 'star') {
                    // ë³„
                    drawStar(ctx, 0, 0, monster.width/2, monster.width/4, 5);
                }
                ctx.restore();
            });

            // ë– ë‹¤ë‹ˆëŠ” ì•ŒíŒŒë²³ ê·¸ë¦¬ê¸°
            floatingLetters.forEach(letter => {
                if (!letter.collected) {
                    const pulse = Math.sin(letter.pulse) * 0.2 + 1;
                    
                    // ì•ŒíŒŒë²³ ë°°ê²½ (ì›í˜•)
                    ctx.save();
                    ctx.shadowColor = letter.color;
                    ctx.shadowBlur = 15;
                    ctx.fillStyle = letter.color;
                    ctx.beginPath();
                    ctx.arc(letter.worldX - cameraX, letter.worldY - cameraY, (letter.width/2) * pulse, 0, Math.PI * 2); // worldX, worldY ê¸°ì¤€
                    ctx.fill();
                    ctx.restore();

                    // ì•ŒíŒŒë²³ í…ìŠ¤íŠ¸
                    ctx.save();
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(letter.letter.toUpperCase(), letter.worldX - cameraX, letter.worldY - cameraY); // worldX, worldY ê¸°ì¤€
                    ctx.fillText(letter.letter.toUpperCase(), letter.worldX - cameraX, letter.worldY - cameraY); // worldX, worldY ê¸°ì¤€
                    ctx.restore();
                }
            });

            // íˆ¬ì‚¬ì²´ íŠ¸ë ˆì¼ ë° íˆ¬ì‚¬ì²´ ê·¸ë¦¬ê¸°
            projectiles.forEach(projectile => {
                // íŠ¸ë ˆì¼ ê·¸ë¦¬ê¸°
                if (projectile.trail.length > 1) {
                    ctx.strokeStyle = `rgba(0, 255, 136, ${projectile.life * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(projectile.trail[0].x, projectile.trail[0].y);
                    for (let i = 1; i < projectile.trail.length; i++) {
                        ctx.lineTo(projectile.trail[i].x, projectile.trail[i].y);
                    }
                    ctx.stroke();
                }

                // íˆ¬ì‚¬ì²´ ë°œê´‘ íš¨ê³¼
                ctx.save();
                ctx.globalAlpha = projectile.life;
                ctx.shadowColor = projectile.color;
                ctx.shadowBlur = 10;
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.worldX - cameraX, projectile.worldY - cameraY, projectile.size, 0, Math.PI * 2); // worldX, worldY ê¸°ì¤€
                ctx.fill();
                ctx.restore();
            });

            // íŒŒí‹°í´ ê·¸ë¦¬ê¸°
            particles.forEach(particle => {
                ctx.save();
                ctx.globalAlpha = particle.life;
                ctx.fillStyle = particle.color;
                ctx.beginPath();
                ctx.arc(particle.x - cameraX, particle.y - cameraY, particle.size, 0, Math.PI * 2); // ì¹´ë©”ë¼ ì˜¤í”„ì…‹ ì ìš©
                ctx.fill();
                ctx.restore();
            });

            // í–‰ì„± ê·¸ë¦¬ê¸°
            planets.forEach(planet => {
                if (planet.exploded) return;
                ctx.save();
                ctx.shadowColor = `rgba(255,0,0,0.5)`;
                ctx.shadowBlur = 30;
                ctx.beginPath();
                ctx.arc(planet.worldX - cameraX, planet.worldY - cameraY, planet.radius, 0, Math.PI * 2);
                ctx.closePath();
                ctx.fillStyle = `rgba(${planet.color.r|0},${planet.color.g|0},${planet.color.b|0},${planet.color.a})`;
                ctx.fill();
                ctx.restore();
            });

            // ì²´ë ¥ë°” ê·¸ë¦¬ê¸° (ê°œì„ ëœ ìŠ¤íƒ€ì¼)
            const healthBarWidth = 150;
            const healthBarHeight = 12;
            const healthPercentage = player.health / player.maxHealth;
            
            // HP ë¼ë²¨
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('HP', 17, canvas.height - 45);
            
            // ì²´ë ¥ë°” ë°°ê²½
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(15, canvas.height - 40, healthBarWidth + 4, healthBarHeight + 4);
            
            // ì²´ë ¥ë°” í…Œë‘ë¦¬
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.strokeRect(15, canvas.height - 40, healthBarWidth + 4, healthBarHeight + 4);
            
            // ì²´ë ¥ë°” ë‚´ë¶€
            const healthGradient = ctx.createLinearGradient(17, 0, 17 + healthBarWidth, 0);
            if (healthPercentage > 0.6) {
                healthGradient.addColorStop(0, '#44ff44');
                healthGradient.addColorStop(1, '#22cc22');
            } else if (healthPercentage > 0.3) {
                healthGradient.addColorStop(0, '#ffaa44');
                healthGradient.addColorStop(1, '#ff8822');
            } else {
                healthGradient.addColorStop(0, '#ff4444');
                healthGradient.addColorStop(1, '#cc2222');
            }
            
            ctx.fillStyle = healthGradient;
            ctx.fillRect(17, canvas.height - 38, healthBarWidth * healthPercentage, healthBarHeight);

            // ê²½í—˜ì¹˜ë°” ê·¸ë¦¬ê¸°
            const expBarWidth = 200;
            const expBarHeight = 8;
            const expPercentage = player.exp / player.expToNext;
            
            // XP ë¼ë²¨
            ctx.fillStyle = 'white';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'right';
            ctx.fillText('XP', canvas.width - expBarWidth - 17, canvas.height - 30);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(canvas.width - expBarWidth - 15, canvas.height - 25, expBarWidth + 4, expBarHeight + 4);
            
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            ctx.strokeRect(canvas.width - expBarWidth - 15, canvas.height - 25, expBarWidth + 4, expBarHeight + 4);
            
            const expGradient = ctx.createLinearGradient(canvas.width - expBarWidth - 13, 0, canvas.width - 13, 0);
            expGradient.addColorStop(0, '#4488ff');
            expGradient.addColorStop(1, '#2266cc');
            ctx.fillStyle = expGradient;
            ctx.fillRect(canvas.width - expBarWidth - 13, canvas.height - 23, expBarWidth * expPercentage, expBarHeight);
        }

        // UI ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateUI() {
            document.getElementById('health').textContent = player.health;
            document.getElementById('level').textContent = player.level;
            document.getElementById('exp').textContent = player.exp;
            document.getElementById('expMax').textContent = player.expToNext;
            document.getElementById('kills').textContent = player.kills;
            document.getElementById('completedWords').textContent = completedWords;
            document.getElementById('time').textContent = gameState.timeElapsed;
        }

        // ë ˆë²¨ì—… í•¨ìˆ˜
        function levelUp() {
            player.level++;
            player.exp = 0;
            player.expToNext = Math.floor(player.expToNext * 2); // ê¸°ì¡´ 1.5ë°° â†’ 2ë°°
            
            // ë ˆë²¨ì—… íŒŒí‹°í´ íš¨ê³¼
            for (let i = 0; i < 20; i++) {
                createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'correct');
            }
            
            gameState.paused = true;
            document.getElementById('levelUpModal').style.display = 'block';
        }

        // ì—…ê·¸ë ˆì´ë“œ ì„ íƒ í•¨ìˆ˜
        function selectUpgrade(type) {
            switch(type) {
                case 'attackSpeed':
                    player.attackSpeed = Math.max(200, player.attackSpeed * 0.8);
                    break;
                case 'moveSpeed':
                    player.speed += 0.5;
                    break;
                case 'projectileSize':
                    player.projectileSize += 1;
                    break;
                case 'health':
                    player.health = Math.min(player.maxHealth, player.health + 30);
                    break;
            }
            
            document.getElementById('levelUpModal').style.display = 'none';
            gameState.paused = false;
        }

        // ê²Œì„ ì˜¤ë²„ í•¨ìˆ˜
        function gameOver() {
            gameState.running = false;
            
            // ê²Œì„ ì˜¤ë²„ íŒŒí‹°í´ íš¨ê³¼
            for (let i = 0; i < 30; i++) {
                createParticle(player.worldX + player.width/2, player.worldY + player.height/2, 'blood');
            }
            
            document.getElementById('finalTime').textContent = gameState.timeElapsed;
            document.getElementById('finalKills').textContent = player.kills;
            document.getElementById('finalWords').textContent = completedWords;
            document.getElementById('finalLevel').textContent = player.level;
            document.getElementById('gameOver').style.display = 'block';
        }

        // ê²Œì„ ì¬ì‹œì‘ í•¨ìˆ˜
        function restartGame() {
            // ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
            gameState.running = true;
            gameState.paused = false;
            gameState.startTime = Date.now();
            gameState.timeElapsed = 0;

            // í”Œë ˆì´ì–´ ì´ˆê¸°í™”
            player.worldX = worldWidth / 2;
            player.worldY = worldHeight / 2;
            player.health = 100;
            player.level = 1;
            player.exp = 0;
            player.expToNext = 10;
            player.kills = 0;
            player.speed = 3;
            player.attackSpeed = 1000;
            player.projectileSize = 6;
            player.angle = 0;

            // ê²Œì„ ë°ì´í„° ì´ˆê¸°í™”
            completedWords = 0;
            selectNewWord();

            // ë°°ì—´ ì´ˆê¸°í™”
            monsters.length = 0;
            projectiles.length = 0;
            floatingLetters.length = 0;
            particles.length = 0;
            bloodParticles.length = 0;
            planets.length = 0; // í–‰ì„± ë°°ì—´ë„ ì´ˆê¸°í™”

            // UI ì´ˆê¸°í™”
            document.getElementById('gameOver').style.display = 'none';
            updateUI();
            // ê²Œì„ ì‹œì‘ ì‹œ planets ìƒì„±
            spawnPlanets();
            // í”Œë ˆì´ì–´, ì¹´ë©”ë¼ ì´ˆê¸°í™”
            resetPlayerAndCamera();
        }

        // ê²Œì„ ë£¨í”„
        function gameLoop() {
            update();
            render();
            requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì‹œì‘
        selectNewWord();
        gameLoop();

        // ë³„ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (ì›ê±°ë¦¬í˜• ëª¬ìŠ¤í„°ìš©)
        function drawStar(ctx, x, y, outerRadius, innerRadius, points) {
            ctx.save();
            ctx.beginPath();
            for (let i = 0; i < points * 2; i++) {
                const angle = (Math.PI / points) * i;
                const r = i % 2 === 0 ? outerRadius : innerRadius;
                ctx.lineTo(
                    x + Math.cos(angle) * r,
                    y + Math.sin(angle) * r
                );
            }
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        // í„°ì¹˜/ë§ˆìš°ìŠ¤ í´ë¦­í•œ ìœ„ì¹˜ë¡œ ì´ë™í•˜ëŠ” ì‹œìŠ¤í…œ ì¶”ê°€
        // í”Œë ˆì´ì–´, ì¹´ë©”ë¼ ì´ˆê¸°í™” í•¨ìˆ˜ ì¶”ê°€
        function resetPlayerAndCamera() {
            player.worldX = worldWidth / 2;
            player.worldY = worldHeight / 2;
            cameraX = player.worldX - canvas.width / 2;
            cameraY = player.worldY - canvas.height / 2;
            // ì¹´ë©”ë¼ ê²½ê³„ ë³´ì •
            cameraX = Math.max(0, Math.min(cameraX, worldWidth - canvas.width));
            cameraY = Math.max(0, Math.min(cameraY, worldHeight - canvas.height));
        }

        // í„°ì¹˜ ì´ë²¤íŠ¸ (ëª¨ë°”ì¼)
        canvas.addEventListener('touchstart', function(e) {
            isPointerDown = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            pointerX = touch.clientX - rect.left + cameraX;
            pointerY = touch.clientY - rect.top + cameraY;
        });
        canvas.addEventListener('touchmove', function(e) {
            if (isPointerDown) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                pointerX = touch.clientX - rect.left + cameraX;
                pointerY = touch.clientY - rect.top + cameraY;
            }
        });
        window.addEventListener('touchend', function() {
            isPointerDown = false;
            pointerX = pointerY = null;
        });
        // ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ (PC)
        canvas.addEventListener('mousedown', function(e) {
            isPointerDown = true;
            const rect = canvas.getBoundingClientRect();
            pointerX = e.clientX - rect.left + cameraX;
            pointerY = e.clientY - rect.top + cameraY;
        });
        canvas.addEventListener('mousemove', function(e) {
            if (isPointerDown) {
                const rect = canvas.getBoundingClientRect();
                pointerX = e.clientX - rect.left + cameraX;
                pointerY = e.clientY - rect.top + cameraY;
            }
        });
        window.addEventListener('mouseup', function() {
            isPointerDown = false;
            pointerX = pointerY = null;
        });

        // canvas í¬ê¸° ë°˜ì‘í˜• ì¡°ì •
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas(); // ê²Œì„ ì‹œì‘ ì‹œì—ë„ í˜¸ì¶œ
    </script>
</body>
</html>